<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>diffmpm.particle API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>diffmpm.particle</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Optional, Sized, Tuple

import jax.numpy as jnp
from jax import lax, vmap
from jax.tree_util import register_pytree_node_class
from jax.typing import ArrayLike

from diffmpm.element import _Element
from diffmpm.material import Material


@register_pytree_node_class
class Particles(Sized):
    &#34;&#34;&#34;Container class for a set of particles.&#34;&#34;&#34;

    def __init__(
        self,
        loc: ArrayLike,
        material: Material,
        element_ids: ArrayLike,
        initialized: Optional[bool] = None,
        data: Optional[Tuple[ArrayLike, ...]] = None,
    ):
        &#34;&#34;&#34;Initialize a container of particles.

        Parameters
        ----------
        loc: ArrayLike
            Location of the particles. Expected shape (nparticles, 1, ndim)
        material: diffmpm.material.Material
            Type of material for the set of particles.
        element_ids: ArrayLike
            The element ids that the particles belong to. This contains
            information that will make sense only with the information of
            the mesh that is being considered.
        initialized: bool
            `False` if particle property arrays like mass need to be initialized.
            If `True`, they are set to values from `data`.
        data: tuple
            Tuple of length 13 that sets arrays for mass, density, volume,
            velocity, acceleration, momentum, strain, stress, strain_rate,
            dstrain, f_ext, reference_loc and volumetric_strain_centroid.
        &#34;&#34;&#34;
        self.material = material
        self.element_ids = element_ids
        loc = jnp.asarray(loc, dtype=jnp.float32)
        if loc.ndim != 3:
            raise ValueError(
                f&#34;`loc` should be of size (nparticles, 1, ndim); &#34; f&#34;found {loc.shape}&#34;
            )
        self.loc = loc

        if initialized is None:
            self.mass = jnp.ones((self.loc.shape[0], 1, 1))
            self.density = (
                jnp.ones_like(self.mass) * self.material.properties[&#34;density&#34;]
            )
            self.volume = jnp.ones_like(self.mass)
            self.size = jnp.zeros_like(self.loc)
            self.velocity = jnp.zeros_like(self.loc)
            self.acceleration = jnp.zeros_like(self.loc)
            self.momentum = jnp.zeros_like(self.loc)
            self.strain = jnp.zeros((self.loc.shape[0], 6, 1))
            self.stress = jnp.zeros((self.loc.shape[0], 6, 1))
            self.strain_rate = jnp.zeros((self.loc.shape[0], 6, 1))
            self.dstrain = jnp.zeros((self.loc.shape[0], 6, 1))
            self.f_ext = jnp.zeros_like(self.loc)
            self.traction = jnp.zeros_like(self.loc)
            self.reference_loc = jnp.zeros_like(self.loc)
            self.dvolumetric_strain = jnp.zeros((self.loc.shape[0], 1))
            self.volumetric_strain_centroid = jnp.zeros((self.loc.shape[0], 1))
        else:
            (
                self.mass,
                self.density,
                self.volume,
                self.size,
                self.velocity,
                self.acceleration,
                self.momentum,
                self.strain,
                self.stress,
                self.strain_rate,
                self.dstrain,
                self.f_ext,
                self.traction,
                self.reference_loc,
                self.dvolumetric_strain,
                self.volumetric_strain_centroid,
            ) = data  # type: ignore
        self.initialized = True

    def tree_flatten(self):
        &#34;&#34;&#34;Flatten class as Pytree type.&#34;&#34;&#34;
        children = (
            self.loc,
            self.element_ids,
            self.initialized,
            self.mass,
            self.density,
            self.volume,
            self.size,
            self.velocity,
            self.acceleration,
            self.momentum,
            self.strain,
            self.stress,
            self.strain_rate,
            self.dstrain,
            self.f_ext,
            self.traction,
            self.reference_loc,
            self.dvolumetric_strain,
            self.volumetric_strain_centroid,
        )
        aux_data = (self.material,)
        return (children, aux_data)

    @classmethod
    def tree_unflatten(cls, aux_data, children):
        &#34;&#34;&#34;Unflatten class from Pytree type.&#34;&#34;&#34;
        return cls(
            children[0],
            aux_data[0],
            children[1],
            initialized=children[2],
            data=children[3:],
        )

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Set length of the class as number of particles.&#34;&#34;&#34;
        return self.loc.shape[0]

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Informative repr showing number of particles.&#34;&#34;&#34;
        return f&#34;Particles(nparticles={len(self)})&#34;

    def set_mass_volume(self, m: ArrayLike):
        &#34;&#34;&#34;Set particle mass.

        Parameters
        ----------
        m: float, array_like
            Mass to be set for particles. If scalar, mass for all
            particles is set to this value.
        &#34;&#34;&#34;
        m = jnp.asarray(m)
        if jnp.isscalar(m):
            self.mass = jnp.ones_like(self.loc) * m
        elif m.shape == self.mass.shape:
            self.mass = m
        else:
            raise ValueError(
                f&#34;Incompatible shapes. Expected {self.mass.shape}, &#34; f&#34;found {m.shape}.&#34;
            )
        self.volume = jnp.divide(self.mass, self.material.properties[&#34;density&#34;])

    def compute_volume(self, elements: _Element, total_elements: int):
        &#34;&#34;&#34;Compute volume of all particles.

        Parameters
        ----------
        elements: diffmpm._Element
            Elements that the particles are present in, and are used to
            compute the particles&#39; volumes.
        total_elements: int
            Total elements present in `elements`.
        &#34;&#34;&#34;
        particles_per_element = jnp.bincount(
            self.element_ids, length=elements.total_elements
        )
        vol = (
            elements.volume.squeeze((1, 2))[self.element_ids]  # type: ignore
            / particles_per_element[self.element_ids]
        )
        self.volume = self.volume.at[:, 0, 0].set(vol)
        self.size = self.size.at[:].set(self.volume ** (1 / self.size.shape[-1]))
        self.mass = self.mass.at[:, 0, 0].set(vol * self.density.squeeze())

    def update_natural_coords(self, elements: _Element):
        r&#34;&#34;&#34;Update natural coordinates for the particles.

        Whenever the particles&#39; physical coordinates change, their
        natural coordinates need to be updated. This function updates
        the natural coordinates of the particles based on the element
        a particle is a part of. The update formula is

        \[
          \xi = (2x - (x_1^e + x_2^e))  / (x_2^e - x_1^e)
        \]

        where \(x_i^e\) are the nodal coordinates of the element the
        particle is in. If a particle is not in any element
        (element_id = -1), its natural coordinate is set to 0.

        Parameters
        ----------
        elements: diffmpm.element._Element
            Elements based on which to update the natural coordinates
            of the particles.
        &#34;&#34;&#34;
        t = vmap(elements.id_to_node_loc)(self.element_ids)
        xi_coords = (self.loc - (t[:, 0, ...] + t[:, 2, ...]) / 2) * (
            2 / (t[:, 2, ...] - t[:, 0, ...])
        )
        self.reference_loc = xi_coords

    def update_position_velocity(
        self, elements: _Element, dt: float, velocity_update: bool
    ):
        &#34;&#34;&#34;Transfer nodal velocity to particles and update particle position.

        The velocity is calculated based on the total force at nodes.

        Parameters
        ----------
        elements: diffmpm.element._Element
            Elements whose nodes are used to transfer the velocity.
        dt: float
            Timestep.
        velocity_update: bool
            If True, velocity is directly used as nodal velocity, else
            velocity is calculated is interpolated nodal acceleration
            multiplied by dt. Default is False.
        &#34;&#34;&#34;
        mapped_positions = elements.shapefn(self.reference_loc)
        mapped_ids = vmap(elements.id_to_node_ids)(self.element_ids).squeeze(-1)
        nodal_velocity = jnp.sum(
            mapped_positions * elements.nodes.velocity[mapped_ids], axis=1
        )
        nodal_acceleration = jnp.sum(
            mapped_positions * elements.nodes.acceleration[mapped_ids],
            axis=1,
        )
        self.velocity = self.velocity.at[:].set(
            lax.cond(
                velocity_update,
                lambda sv, nv, na, t: nv,
                lambda sv, nv, na, t: sv + na * t,
                self.velocity,
                nodal_velocity,
                nodal_acceleration,
                dt,
            )
        )
        self.loc = self.loc.at[:].add(nodal_velocity * dt)
        self.momentum = self.momentum.at[:].set(self.mass * self.velocity)

    def compute_strain(self, elements: _Element, dt: float):
        &#34;&#34;&#34;Compute the strain on all particles.

        This is done by first calculating the strain rate for the particles
        and then calculating strain as `strain += strain rate * dt`.

        Parameters
        ----------
        elements: diffmpm.element._Element
            Elements whose nodes are used to calculate the strain.
        dt : float
            Timestep.
        &#34;&#34;&#34;
        mapped_coords = vmap(elements.id_to_node_loc)(self.element_ids).squeeze(2)
        dn_dx_ = vmap(elements.shapefn_grad)(
            self.reference_loc[:, jnp.newaxis, ...], mapped_coords
        )
        self.strain_rate = self._compute_strain_rate(dn_dx_, elements)
        self.dstrain = self.dstrain.at[:].set(self.strain_rate * dt)

        self.strain = self.strain.at[:].add(self.dstrain)
        centroids = jnp.zeros_like(self.loc)
        dn_dx_centroid_ = vmap(elements.shapefn_grad)(
            centroids[:, jnp.newaxis, ...], mapped_coords
        )
        strain_rate_centroid = self._compute_strain_rate(dn_dx_centroid_, elements)
        ndim = self.loc.shape[-1]
        self.dvolumetric_strain = dt * strain_rate_centroid[:, :ndim].sum(axis=1)
        self.volumetric_strain_centroid = self.volumetric_strain_centroid.at[:].add(
            self.dvolumetric_strain
        )

    def _compute_strain_rate(self, dn_dx: ArrayLike, elements: _Element):
        &#34;&#34;&#34;Compute the strain rate for particles.

        Parameters
        ----------
        dn_dx: ArrayLike
            The gradient of the shape function. Expected shape
            `(nparticles, 1, ndim)`
        elements: diffmpm.element._Element
            Elements whose nodes are used to calculate the strain rate.
        &#34;&#34;&#34;
        dn_dx = jnp.asarray(dn_dx)
        strain_rate = jnp.zeros((dn_dx.shape[0], 6, 1))  # (nparticles, 6, 1)
        mapped_vel = vmap(elements.id_to_node_vel)(
            self.element_ids
        )  # (nparticles, 2, 1)

        temp = mapped_vel.squeeze(2)

        def _step(pid, args):
            dndx, nvel, strain_rate = args
            matmul = dndx[pid].T @ nvel[pid]
            strain_rate = strain_rate.at[pid, 0].add(matmul[0, 0])
            strain_rate = strain_rate.at[pid, 1].add(matmul[1, 1])
            strain_rate = strain_rate.at[pid, 3].add(matmul[0, 1] + matmul[1, 0])
            return dndx, nvel, strain_rate

        args = (dn_dx, temp, strain_rate)
        _, _, strain_rate = lax.fori_loop(0, self.loc.shape[0], _step, args)
        strain_rate = jnp.where(
            jnp.abs(strain_rate) &lt; 1e-12, jnp.zeros_like(strain_rate), strain_rate
        )
        return strain_rate

    def compute_stress(self, *args):
        &#34;&#34;&#34;Compute the strain on all particles.

        This calculation is governed by the material of the
        particles. The stress calculated by the material is then
        added to the particles current stress values.
        &#34;&#34;&#34;
        self.stress = self.stress.at[:].add(self.material.compute_stress(self.dstrain))

    def update_volume(self, *args):
        &#34;&#34;&#34;Update volume based on central strain rate.&#34;&#34;&#34;
        self.volume = self.volume.at[:, 0, :].multiply(1 + self.dvolumetric_strain)
        self.density = self.density.at[:, 0, :].divide(1 + self.dvolumetric_strain)

    def assign_traction(self, pids: ArrayLike, dir: int, traction_: float):
        &#34;&#34;&#34;Assign traction to particles.

        Parameters
        ----------
        pids: ArrayLike
            IDs of the particles to which traction should be applied.
        dir: int
            The direction in which traction should be applied.
        traction_: float
            Traction value to be applied in the direction.
        &#34;&#34;&#34;
        self.traction = self.traction.at[pids, 0, dir].add(
            traction_ * self.volume[pids, 0, 0] / self.size[pids, 0, dir]
        )

    def zero_traction(self, *args):
        &#34;&#34;&#34;Set all traction values to 0.&#34;&#34;&#34;
        self.traction = self.traction.at[:].set(0)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="diffmpm.particle.Particles"><code class="flex name class">
<span>class <span class="ident">Particles</span></span>
<span>(</span><span>loc: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], material: <a title="diffmpm.material.Material" href="material.html#diffmpm.material.Material">Material</a>, element_ids: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], initialized: Optional[bool] = None, data: Optional[Tuple[Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], ...]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Container class for a set of particles.</p>
<p>Initialize a container of particles.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>loc</code></strong> :&ensp;<code>ArrayLike</code></dt>
<dd>Location of the particles. Expected shape (nparticles, 1, ndim)</dd>
<dt><strong><code>material</code></strong> :&ensp;<code><a title="diffmpm.material.Material" href="material.html#diffmpm.material.Material">Material</a></code></dt>
<dd>Type of material for the set of particles.</dd>
<dt><strong><code>element_ids</code></strong> :&ensp;<code>ArrayLike</code></dt>
<dd>The element ids that the particles belong to. This contains
information that will make sense only with the information of
the mesh that is being considered.</dd>
<dt><strong><code>initialized</code></strong> :&ensp;<code>bool</code></dt>
<dd><code>False</code> if particle property arrays like mass need to be initialized.
If <code>True</code>, they are set to values from <code>data</code>.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Tuple of length 13 that sets arrays for mass, density, volume,
velocity, acceleration, momentum, strain, stress, strain_rate,
dstrain, f_ext, reference_loc and volumetric_strain_centroid.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@register_pytree_node_class
class Particles(Sized):
    &#34;&#34;&#34;Container class for a set of particles.&#34;&#34;&#34;

    def __init__(
        self,
        loc: ArrayLike,
        material: Material,
        element_ids: ArrayLike,
        initialized: Optional[bool] = None,
        data: Optional[Tuple[ArrayLike, ...]] = None,
    ):
        &#34;&#34;&#34;Initialize a container of particles.

        Parameters
        ----------
        loc: ArrayLike
            Location of the particles. Expected shape (nparticles, 1, ndim)
        material: diffmpm.material.Material
            Type of material for the set of particles.
        element_ids: ArrayLike
            The element ids that the particles belong to. This contains
            information that will make sense only with the information of
            the mesh that is being considered.
        initialized: bool
            `False` if particle property arrays like mass need to be initialized.
            If `True`, they are set to values from `data`.
        data: tuple
            Tuple of length 13 that sets arrays for mass, density, volume,
            velocity, acceleration, momentum, strain, stress, strain_rate,
            dstrain, f_ext, reference_loc and volumetric_strain_centroid.
        &#34;&#34;&#34;
        self.material = material
        self.element_ids = element_ids
        loc = jnp.asarray(loc, dtype=jnp.float32)
        if loc.ndim != 3:
            raise ValueError(
                f&#34;`loc` should be of size (nparticles, 1, ndim); &#34; f&#34;found {loc.shape}&#34;
            )
        self.loc = loc

        if initialized is None:
            self.mass = jnp.ones((self.loc.shape[0], 1, 1))
            self.density = (
                jnp.ones_like(self.mass) * self.material.properties[&#34;density&#34;]
            )
            self.volume = jnp.ones_like(self.mass)
            self.size = jnp.zeros_like(self.loc)
            self.velocity = jnp.zeros_like(self.loc)
            self.acceleration = jnp.zeros_like(self.loc)
            self.momentum = jnp.zeros_like(self.loc)
            self.strain = jnp.zeros((self.loc.shape[0], 6, 1))
            self.stress = jnp.zeros((self.loc.shape[0], 6, 1))
            self.strain_rate = jnp.zeros((self.loc.shape[0], 6, 1))
            self.dstrain = jnp.zeros((self.loc.shape[0], 6, 1))
            self.f_ext = jnp.zeros_like(self.loc)
            self.traction = jnp.zeros_like(self.loc)
            self.reference_loc = jnp.zeros_like(self.loc)
            self.dvolumetric_strain = jnp.zeros((self.loc.shape[0], 1))
            self.volumetric_strain_centroid = jnp.zeros((self.loc.shape[0], 1))
        else:
            (
                self.mass,
                self.density,
                self.volume,
                self.size,
                self.velocity,
                self.acceleration,
                self.momentum,
                self.strain,
                self.stress,
                self.strain_rate,
                self.dstrain,
                self.f_ext,
                self.traction,
                self.reference_loc,
                self.dvolumetric_strain,
                self.volumetric_strain_centroid,
            ) = data  # type: ignore
        self.initialized = True

    def tree_flatten(self):
        &#34;&#34;&#34;Flatten class as Pytree type.&#34;&#34;&#34;
        children = (
            self.loc,
            self.element_ids,
            self.initialized,
            self.mass,
            self.density,
            self.volume,
            self.size,
            self.velocity,
            self.acceleration,
            self.momentum,
            self.strain,
            self.stress,
            self.strain_rate,
            self.dstrain,
            self.f_ext,
            self.traction,
            self.reference_loc,
            self.dvolumetric_strain,
            self.volumetric_strain_centroid,
        )
        aux_data = (self.material,)
        return (children, aux_data)

    @classmethod
    def tree_unflatten(cls, aux_data, children):
        &#34;&#34;&#34;Unflatten class from Pytree type.&#34;&#34;&#34;
        return cls(
            children[0],
            aux_data[0],
            children[1],
            initialized=children[2],
            data=children[3:],
        )

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Set length of the class as number of particles.&#34;&#34;&#34;
        return self.loc.shape[0]

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Informative repr showing number of particles.&#34;&#34;&#34;
        return f&#34;Particles(nparticles={len(self)})&#34;

    def set_mass_volume(self, m: ArrayLike):
        &#34;&#34;&#34;Set particle mass.

        Parameters
        ----------
        m: float, array_like
            Mass to be set for particles. If scalar, mass for all
            particles is set to this value.
        &#34;&#34;&#34;
        m = jnp.asarray(m)
        if jnp.isscalar(m):
            self.mass = jnp.ones_like(self.loc) * m
        elif m.shape == self.mass.shape:
            self.mass = m
        else:
            raise ValueError(
                f&#34;Incompatible shapes. Expected {self.mass.shape}, &#34; f&#34;found {m.shape}.&#34;
            )
        self.volume = jnp.divide(self.mass, self.material.properties[&#34;density&#34;])

    def compute_volume(self, elements: _Element, total_elements: int):
        &#34;&#34;&#34;Compute volume of all particles.

        Parameters
        ----------
        elements: diffmpm._Element
            Elements that the particles are present in, and are used to
            compute the particles&#39; volumes.
        total_elements: int
            Total elements present in `elements`.
        &#34;&#34;&#34;
        particles_per_element = jnp.bincount(
            self.element_ids, length=elements.total_elements
        )
        vol = (
            elements.volume.squeeze((1, 2))[self.element_ids]  # type: ignore
            / particles_per_element[self.element_ids]
        )
        self.volume = self.volume.at[:, 0, 0].set(vol)
        self.size = self.size.at[:].set(self.volume ** (1 / self.size.shape[-1]))
        self.mass = self.mass.at[:, 0, 0].set(vol * self.density.squeeze())

    def update_natural_coords(self, elements: _Element):
        r&#34;&#34;&#34;Update natural coordinates for the particles.

        Whenever the particles&#39; physical coordinates change, their
        natural coordinates need to be updated. This function updates
        the natural coordinates of the particles based on the element
        a particle is a part of. The update formula is

        \[
          \xi = (2x - (x_1^e + x_2^e))  / (x_2^e - x_1^e)
        \]

        where \(x_i^e\) are the nodal coordinates of the element the
        particle is in. If a particle is not in any element
        (element_id = -1), its natural coordinate is set to 0.

        Parameters
        ----------
        elements: diffmpm.element._Element
            Elements based on which to update the natural coordinates
            of the particles.
        &#34;&#34;&#34;
        t = vmap(elements.id_to_node_loc)(self.element_ids)
        xi_coords = (self.loc - (t[:, 0, ...] + t[:, 2, ...]) / 2) * (
            2 / (t[:, 2, ...] - t[:, 0, ...])
        )
        self.reference_loc = xi_coords

    def update_position_velocity(
        self, elements: _Element, dt: float, velocity_update: bool
    ):
        &#34;&#34;&#34;Transfer nodal velocity to particles and update particle position.

        The velocity is calculated based on the total force at nodes.

        Parameters
        ----------
        elements: diffmpm.element._Element
            Elements whose nodes are used to transfer the velocity.
        dt: float
            Timestep.
        velocity_update: bool
            If True, velocity is directly used as nodal velocity, else
            velocity is calculated is interpolated nodal acceleration
            multiplied by dt. Default is False.
        &#34;&#34;&#34;
        mapped_positions = elements.shapefn(self.reference_loc)
        mapped_ids = vmap(elements.id_to_node_ids)(self.element_ids).squeeze(-1)
        nodal_velocity = jnp.sum(
            mapped_positions * elements.nodes.velocity[mapped_ids], axis=1
        )
        nodal_acceleration = jnp.sum(
            mapped_positions * elements.nodes.acceleration[mapped_ids],
            axis=1,
        )
        self.velocity = self.velocity.at[:].set(
            lax.cond(
                velocity_update,
                lambda sv, nv, na, t: nv,
                lambda sv, nv, na, t: sv + na * t,
                self.velocity,
                nodal_velocity,
                nodal_acceleration,
                dt,
            )
        )
        self.loc = self.loc.at[:].add(nodal_velocity * dt)
        self.momentum = self.momentum.at[:].set(self.mass * self.velocity)

    def compute_strain(self, elements: _Element, dt: float):
        &#34;&#34;&#34;Compute the strain on all particles.

        This is done by first calculating the strain rate for the particles
        and then calculating strain as `strain += strain rate * dt`.

        Parameters
        ----------
        elements: diffmpm.element._Element
            Elements whose nodes are used to calculate the strain.
        dt : float
            Timestep.
        &#34;&#34;&#34;
        mapped_coords = vmap(elements.id_to_node_loc)(self.element_ids).squeeze(2)
        dn_dx_ = vmap(elements.shapefn_grad)(
            self.reference_loc[:, jnp.newaxis, ...], mapped_coords
        )
        self.strain_rate = self._compute_strain_rate(dn_dx_, elements)
        self.dstrain = self.dstrain.at[:].set(self.strain_rate * dt)

        self.strain = self.strain.at[:].add(self.dstrain)
        centroids = jnp.zeros_like(self.loc)
        dn_dx_centroid_ = vmap(elements.shapefn_grad)(
            centroids[:, jnp.newaxis, ...], mapped_coords
        )
        strain_rate_centroid = self._compute_strain_rate(dn_dx_centroid_, elements)
        ndim = self.loc.shape[-1]
        self.dvolumetric_strain = dt * strain_rate_centroid[:, :ndim].sum(axis=1)
        self.volumetric_strain_centroid = self.volumetric_strain_centroid.at[:].add(
            self.dvolumetric_strain
        )

    def _compute_strain_rate(self, dn_dx: ArrayLike, elements: _Element):
        &#34;&#34;&#34;Compute the strain rate for particles.

        Parameters
        ----------
        dn_dx: ArrayLike
            The gradient of the shape function. Expected shape
            `(nparticles, 1, ndim)`
        elements: diffmpm.element._Element
            Elements whose nodes are used to calculate the strain rate.
        &#34;&#34;&#34;
        dn_dx = jnp.asarray(dn_dx)
        strain_rate = jnp.zeros((dn_dx.shape[0], 6, 1))  # (nparticles, 6, 1)
        mapped_vel = vmap(elements.id_to_node_vel)(
            self.element_ids
        )  # (nparticles, 2, 1)

        temp = mapped_vel.squeeze(2)

        def _step(pid, args):
            dndx, nvel, strain_rate = args
            matmul = dndx[pid].T @ nvel[pid]
            strain_rate = strain_rate.at[pid, 0].add(matmul[0, 0])
            strain_rate = strain_rate.at[pid, 1].add(matmul[1, 1])
            strain_rate = strain_rate.at[pid, 3].add(matmul[0, 1] + matmul[1, 0])
            return dndx, nvel, strain_rate

        args = (dn_dx, temp, strain_rate)
        _, _, strain_rate = lax.fori_loop(0, self.loc.shape[0], _step, args)
        strain_rate = jnp.where(
            jnp.abs(strain_rate) &lt; 1e-12, jnp.zeros_like(strain_rate), strain_rate
        )
        return strain_rate

    def compute_stress(self, *args):
        &#34;&#34;&#34;Compute the strain on all particles.

        This calculation is governed by the material of the
        particles. The stress calculated by the material is then
        added to the particles current stress values.
        &#34;&#34;&#34;
        self.stress = self.stress.at[:].add(self.material.compute_stress(self.dstrain))

    def update_volume(self, *args):
        &#34;&#34;&#34;Update volume based on central strain rate.&#34;&#34;&#34;
        self.volume = self.volume.at[:, 0, :].multiply(1 + self.dvolumetric_strain)
        self.density = self.density.at[:, 0, :].divide(1 + self.dvolumetric_strain)

    def assign_traction(self, pids: ArrayLike, dir: int, traction_: float):
        &#34;&#34;&#34;Assign traction to particles.

        Parameters
        ----------
        pids: ArrayLike
            IDs of the particles to which traction should be applied.
        dir: int
            The direction in which traction should be applied.
        traction_: float
            Traction value to be applied in the direction.
        &#34;&#34;&#34;
        self.traction = self.traction.at[pids, 0, dir].add(
            traction_ * self.volume[pids, 0, 0] / self.size[pids, 0, dir]
        )

    def zero_traction(self, *args):
        &#34;&#34;&#34;Set all traction values to 0.&#34;&#34;&#34;
        self.traction = self.traction.at[:].set(0)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.Sized</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="diffmpm.particle.Particles.tree_unflatten"><code class="name flex">
<span>def <span class="ident">tree_unflatten</span></span>(<span>aux_data, children)</span>
</code></dt>
<dd>
<div class="desc"><p>Unflatten class from Pytree type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def tree_unflatten(cls, aux_data, children):
    &#34;&#34;&#34;Unflatten class from Pytree type.&#34;&#34;&#34;
    return cls(
        children[0],
        aux_data[0],
        children[1],
        initialized=children[2],
        data=children[3:],
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="diffmpm.particle.Particles.assign_traction"><code class="name flex">
<span>def <span class="ident">assign_traction</span></span>(<span>self, pids: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex], dir: int, traction_: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Assign traction to particles.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pids</code></strong> :&ensp;<code>ArrayLike</code></dt>
<dd>IDs of the particles to which traction should be applied.</dd>
<dt><strong><code>dir</code></strong> :&ensp;<code>int</code></dt>
<dd>The direction in which traction should be applied.</dd>
<dt><strong><code>traction_</code></strong> :&ensp;<code>float</code></dt>
<dd>Traction value to be applied in the direction.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_traction(self, pids: ArrayLike, dir: int, traction_: float):
    &#34;&#34;&#34;Assign traction to particles.

    Parameters
    ----------
    pids: ArrayLike
        IDs of the particles to which traction should be applied.
    dir: int
        The direction in which traction should be applied.
    traction_: float
        Traction value to be applied in the direction.
    &#34;&#34;&#34;
    self.traction = self.traction.at[pids, 0, dir].add(
        traction_ * self.volume[pids, 0, 0] / self.size[pids, 0, dir]
    )</code></pre>
</details>
</dd>
<dt id="diffmpm.particle.Particles.compute_strain"><code class="name flex">
<span>def <span class="ident">compute_strain</span></span>(<span>self, elements: <a title="diffmpm.element._Element" href="element.html#diffmpm.element._Element">_Element</a>, dt: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the strain on all particles.</p>
<p>This is done by first calculating the strain rate for the particles
and then calculating strain as <code>strain += strain rate * dt</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elements</code></strong> :&ensp;<code><a title="diffmpm.element._Element" href="element.html#diffmpm.element._Element">_Element</a></code></dt>
<dd>Elements whose nodes are used to calculate the strain.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Timestep.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_strain(self, elements: _Element, dt: float):
    &#34;&#34;&#34;Compute the strain on all particles.

    This is done by first calculating the strain rate for the particles
    and then calculating strain as `strain += strain rate * dt`.

    Parameters
    ----------
    elements: diffmpm.element._Element
        Elements whose nodes are used to calculate the strain.
    dt : float
        Timestep.
    &#34;&#34;&#34;
    mapped_coords = vmap(elements.id_to_node_loc)(self.element_ids).squeeze(2)
    dn_dx_ = vmap(elements.shapefn_grad)(
        self.reference_loc[:, jnp.newaxis, ...], mapped_coords
    )
    self.strain_rate = self._compute_strain_rate(dn_dx_, elements)
    self.dstrain = self.dstrain.at[:].set(self.strain_rate * dt)

    self.strain = self.strain.at[:].add(self.dstrain)
    centroids = jnp.zeros_like(self.loc)
    dn_dx_centroid_ = vmap(elements.shapefn_grad)(
        centroids[:, jnp.newaxis, ...], mapped_coords
    )
    strain_rate_centroid = self._compute_strain_rate(dn_dx_centroid_, elements)
    ndim = self.loc.shape[-1]
    self.dvolumetric_strain = dt * strain_rate_centroid[:, :ndim].sum(axis=1)
    self.volumetric_strain_centroid = self.volumetric_strain_centroid.at[:].add(
        self.dvolumetric_strain
    )</code></pre>
</details>
</dd>
<dt id="diffmpm.particle.Particles.compute_stress"><code class="name flex">
<span>def <span class="ident">compute_stress</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the strain on all particles.</p>
<p>This calculation is governed by the material of the
particles. The stress calculated by the material is then
added to the particles current stress values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_stress(self, *args):
    &#34;&#34;&#34;Compute the strain on all particles.

    This calculation is governed by the material of the
    particles. The stress calculated by the material is then
    added to the particles current stress values.
    &#34;&#34;&#34;
    self.stress = self.stress.at[:].add(self.material.compute_stress(self.dstrain))</code></pre>
</details>
</dd>
<dt id="diffmpm.particle.Particles.compute_volume"><code class="name flex">
<span>def <span class="ident">compute_volume</span></span>(<span>self, elements: <a title="diffmpm.element._Element" href="element.html#diffmpm.element._Element">_Element</a>, total_elements: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute volume of all particles.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elements</code></strong> :&ensp;<code>diffmpm._Element</code></dt>
<dd>Elements that the particles are present in, and are used to
compute the particles' volumes.</dd>
<dt><strong><code>total_elements</code></strong> :&ensp;<code>int</code></dt>
<dd>Total elements present in <code>elements</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_volume(self, elements: _Element, total_elements: int):
    &#34;&#34;&#34;Compute volume of all particles.

    Parameters
    ----------
    elements: diffmpm._Element
        Elements that the particles are present in, and are used to
        compute the particles&#39; volumes.
    total_elements: int
        Total elements present in `elements`.
    &#34;&#34;&#34;
    particles_per_element = jnp.bincount(
        self.element_ids, length=elements.total_elements
    )
    vol = (
        elements.volume.squeeze((1, 2))[self.element_ids]  # type: ignore
        / particles_per_element[self.element_ids]
    )
    self.volume = self.volume.at[:, 0, 0].set(vol)
    self.size = self.size.at[:].set(self.volume ** (1 / self.size.shape[-1]))
    self.mass = self.mass.at[:, 0, 0].set(vol * self.density.squeeze())</code></pre>
</details>
</dd>
<dt id="diffmpm.particle.Particles.set_mass_volume"><code class="name flex">
<span>def <span class="ident">set_mass_volume</span></span>(<span>self, m: Union[jax.Array, numpy.ndarray, numpy.bool_, numpy.number, bool, int, float, complex])</span>
</code></dt>
<dd>
<div class="desc"><p>Set particle mass.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>m</code></strong> :&ensp;<code>float, array_like</code></dt>
<dd>Mass to be set for particles. If scalar, mass for all
particles is set to this value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_mass_volume(self, m: ArrayLike):
    &#34;&#34;&#34;Set particle mass.

    Parameters
    ----------
    m: float, array_like
        Mass to be set for particles. If scalar, mass for all
        particles is set to this value.
    &#34;&#34;&#34;
    m = jnp.asarray(m)
    if jnp.isscalar(m):
        self.mass = jnp.ones_like(self.loc) * m
    elif m.shape == self.mass.shape:
        self.mass = m
    else:
        raise ValueError(
            f&#34;Incompatible shapes. Expected {self.mass.shape}, &#34; f&#34;found {m.shape}.&#34;
        )
    self.volume = jnp.divide(self.mass, self.material.properties[&#34;density&#34;])</code></pre>
</details>
</dd>
<dt id="diffmpm.particle.Particles.tree_flatten"><code class="name flex">
<span>def <span class="ident">tree_flatten</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Flatten class as Pytree type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tree_flatten(self):
    &#34;&#34;&#34;Flatten class as Pytree type.&#34;&#34;&#34;
    children = (
        self.loc,
        self.element_ids,
        self.initialized,
        self.mass,
        self.density,
        self.volume,
        self.size,
        self.velocity,
        self.acceleration,
        self.momentum,
        self.strain,
        self.stress,
        self.strain_rate,
        self.dstrain,
        self.f_ext,
        self.traction,
        self.reference_loc,
        self.dvolumetric_strain,
        self.volumetric_strain_centroid,
    )
    aux_data = (self.material,)
    return (children, aux_data)</code></pre>
</details>
</dd>
<dt id="diffmpm.particle.Particles.update_natural_coords"><code class="name flex">
<span>def <span class="ident">update_natural_coords</span></span>(<span>self, elements: <a title="diffmpm.element._Element" href="element.html#diffmpm.element._Element">_Element</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Update natural coordinates for the particles.</p>
<p>Whenever the particles' physical coordinates change, their
natural coordinates need to be updated. This function updates
the natural coordinates of the particles based on the element
a particle is a part of. The update formula is</p>
<p><span><span class="MathJax_Preview">
\xi = (2x - (x_1^e + x_2^e))
/ (x_2^e - x_1^e)
</span><script type="math/tex; mode=display">
\xi = (2x - (x_1^e + x_2^e))
/ (x_2^e - x_1^e)
</script></span></p>
<p>where <span><span class="MathJax_Preview">x_i^e</span><script type="math/tex">x_i^e</script></span> are the nodal coordinates of the element the
particle is in. If a particle is not in any element
(element_id = -1), its natural coordinate is set to 0.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elements</code></strong> :&ensp;<code><a title="diffmpm.element._Element" href="element.html#diffmpm.element._Element">_Element</a></code></dt>
<dd>Elements based on which to update the natural coordinates
of the particles.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_natural_coords(self, elements: _Element):
    r&#34;&#34;&#34;Update natural coordinates for the particles.

    Whenever the particles&#39; physical coordinates change, their
    natural coordinates need to be updated. This function updates
    the natural coordinates of the particles based on the element
    a particle is a part of. The update formula is

    \[
      \xi = (2x - (x_1^e + x_2^e))  / (x_2^e - x_1^e)
    \]

    where \(x_i^e\) are the nodal coordinates of the element the
    particle is in. If a particle is not in any element
    (element_id = -1), its natural coordinate is set to 0.

    Parameters
    ----------
    elements: diffmpm.element._Element
        Elements based on which to update the natural coordinates
        of the particles.
    &#34;&#34;&#34;
    t = vmap(elements.id_to_node_loc)(self.element_ids)
    xi_coords = (self.loc - (t[:, 0, ...] + t[:, 2, ...]) / 2) * (
        2 / (t[:, 2, ...] - t[:, 0, ...])
    )
    self.reference_loc = xi_coords</code></pre>
</details>
</dd>
<dt id="diffmpm.particle.Particles.update_position_velocity"><code class="name flex">
<span>def <span class="ident">update_position_velocity</span></span>(<span>self, elements: <a title="diffmpm.element._Element" href="element.html#diffmpm.element._Element">_Element</a>, dt: float, velocity_update: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Transfer nodal velocity to particles and update particle position.</p>
<p>The velocity is calculated based on the total force at nodes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elements</code></strong> :&ensp;<code><a title="diffmpm.element._Element" href="element.html#diffmpm.element._Element">_Element</a></code></dt>
<dd>Elements whose nodes are used to transfer the velocity.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Timestep.</dd>
<dt><strong><code>velocity_update</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, velocity is directly used as nodal velocity, else
velocity is calculated is interpolated nodal acceleration
multiplied by dt. Default is False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_position_velocity(
    self, elements: _Element, dt: float, velocity_update: bool
):
    &#34;&#34;&#34;Transfer nodal velocity to particles and update particle position.

    The velocity is calculated based on the total force at nodes.

    Parameters
    ----------
    elements: diffmpm.element._Element
        Elements whose nodes are used to transfer the velocity.
    dt: float
        Timestep.
    velocity_update: bool
        If True, velocity is directly used as nodal velocity, else
        velocity is calculated is interpolated nodal acceleration
        multiplied by dt. Default is False.
    &#34;&#34;&#34;
    mapped_positions = elements.shapefn(self.reference_loc)
    mapped_ids = vmap(elements.id_to_node_ids)(self.element_ids).squeeze(-1)
    nodal_velocity = jnp.sum(
        mapped_positions * elements.nodes.velocity[mapped_ids], axis=1
    )
    nodal_acceleration = jnp.sum(
        mapped_positions * elements.nodes.acceleration[mapped_ids],
        axis=1,
    )
    self.velocity = self.velocity.at[:].set(
        lax.cond(
            velocity_update,
            lambda sv, nv, na, t: nv,
            lambda sv, nv, na, t: sv + na * t,
            self.velocity,
            nodal_velocity,
            nodal_acceleration,
            dt,
        )
    )
    self.loc = self.loc.at[:].add(nodal_velocity * dt)
    self.momentum = self.momentum.at[:].set(self.mass * self.velocity)</code></pre>
</details>
</dd>
<dt id="diffmpm.particle.Particles.update_volume"><code class="name flex">
<span>def <span class="ident">update_volume</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Update volume based on central strain rate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_volume(self, *args):
    &#34;&#34;&#34;Update volume based on central strain rate.&#34;&#34;&#34;
    self.volume = self.volume.at[:, 0, :].multiply(1 + self.dvolumetric_strain)
    self.density = self.density.at[:, 0, :].divide(1 + self.dvolumetric_strain)</code></pre>
</details>
</dd>
<dt id="diffmpm.particle.Particles.zero_traction"><code class="name flex">
<span>def <span class="ident">zero_traction</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Set all traction values to 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zero_traction(self, *args):
    &#34;&#34;&#34;Set all traction values to 0.&#34;&#34;&#34;
    self.traction = self.traction.at[:].set(0)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="diffmpm" href="index.html">diffmpm</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="diffmpm.particle.Particles" href="#diffmpm.particle.Particles">Particles</a></code></h4>
<ul class="">
<li><code><a title="diffmpm.particle.Particles.assign_traction" href="#diffmpm.particle.Particles.assign_traction">assign_traction</a></code></li>
<li><code><a title="diffmpm.particle.Particles.compute_strain" href="#diffmpm.particle.Particles.compute_strain">compute_strain</a></code></li>
<li><code><a title="diffmpm.particle.Particles.compute_stress" href="#diffmpm.particle.Particles.compute_stress">compute_stress</a></code></li>
<li><code><a title="diffmpm.particle.Particles.compute_volume" href="#diffmpm.particle.Particles.compute_volume">compute_volume</a></code></li>
<li><code><a title="diffmpm.particle.Particles.set_mass_volume" href="#diffmpm.particle.Particles.set_mass_volume">set_mass_volume</a></code></li>
<li><code><a title="diffmpm.particle.Particles.tree_flatten" href="#diffmpm.particle.Particles.tree_flatten">tree_flatten</a></code></li>
<li><code><a title="diffmpm.particle.Particles.tree_unflatten" href="#diffmpm.particle.Particles.tree_unflatten">tree_unflatten</a></code></li>
<li><code><a title="diffmpm.particle.Particles.update_natural_coords" href="#diffmpm.particle.Particles.update_natural_coords">update_natural_coords</a></code></li>
<li><code><a title="diffmpm.particle.Particles.update_position_velocity" href="#diffmpm.particle.Particles.update_position_velocity">update_position_velocity</a></code></li>
<li><code><a title="diffmpm.particle.Particles.update_volume" href="#diffmpm.particle.Particles.update_volume">update_volume</a></code></li>
<li><code><a title="diffmpm.particle.Particles.zero_traction" href="#diffmpm.particle.Particles.zero_traction">zero_traction</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>