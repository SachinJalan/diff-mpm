<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>diffmpm.element API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>diffmpm.element</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import abc
import itertools
from typing import TYPE_CHECKING, Optional, Sequence, Tuple

if TYPE_CHECKING:
    from diffmpm.particle import Particles

import jax.numpy as jnp
from jax import Array, jacobian, jit, lax, vmap
from jax.tree_util import register_pytree_node_class
from jax.typing import ArrayLike

from diffmpm.constraint import Constraint
from diffmpm.node import Nodes

__all__ = [&#34;_Element&#34;, &#34;Linear1D&#34;, &#34;Quadrilateral4Node&#34;]


class _Element(abc.ABC):
    &#34;&#34;&#34;Base element class that is inherited by all types of Elements.&#34;&#34;&#34;

    nodes: Nodes
    total_elements: int
    concentrated_nodal_forces: Sequence
    volume: Array

    @abc.abstractmethod
    def id_to_node_ids(self, id: ArrayLike) -&gt; Array:
        &#34;&#34;&#34;Node IDs corresponding to element `id`.

        This method is implemented by each of the subclass.

        Parameters
        ----------
        id : int
            Element ID.

        Returns
        -------
        ArrayLike
            Nodal IDs of the element.
        &#34;&#34;&#34;
        ...

    def id_to_node_loc(self, id: ArrayLike) -&gt; Array:
        &#34;&#34;&#34;Node locations corresponding to element `id`.

        Parameters
        ----------
        id : int
            Element ID.

        Returns
        -------
        ArrayLike
            Nodal locations for the element. Shape of returned
            array is `(nodes_in_element, 1, ndim)`
        &#34;&#34;&#34;
        node_ids = self.id_to_node_ids(id).squeeze()
        return self.nodes.loc[node_ids]

    def id_to_node_vel(self, id: ArrayLike) -&gt; Array:
        &#34;&#34;&#34;Node velocities corresponding to element `id`.

        Parameters
        ----------
        id : int
            Element ID.

        Returns
        -------
        ArrayLike
            Nodal velocities for the element. Shape of returned
            array is `(nodes_in_element, 1, ndim)`
        &#34;&#34;&#34;
        node_ids = self.id_to_node_ids(id).squeeze()
        return self.nodes.velocity[node_ids]

    def tree_flatten(self):
        children = (self.nodes, self.volume)
        aux_data = (
            self.nelements,
            self.total_elements,
            self.el_len,
            self.constraints,
            self.concentrated_nodal_forces,
            self.initialized,
        )
        return children, aux_data

    @classmethod
    def tree_unflatten(cls, aux_data, children):
        return cls(
            aux_data[0],
            aux_data[1],
            aux_data[2],
            aux_data[3],
            nodes=children[0],
            concentrated_nodal_forces=aux_data[4],
            initialized=aux_data[5],
            volume=children[1],
        )

    @abc.abstractmethod
    def shapefn(self, xi: ArrayLike):
        &#34;&#34;&#34;Evaluate Shape function for element type.&#34;&#34;&#34;
        ...

    @abc.abstractmethod
    def shapefn_grad(self, xi: ArrayLike, coords: ArrayLike):
        &#34;&#34;&#34;Evaluate gradient of shape function for element type.&#34;&#34;&#34;
        ...

    @abc.abstractmethod
    def set_particle_element_ids(self, particles: Particles):
        &#34;&#34;&#34;Set the element IDs that particles are present in.&#34;&#34;&#34;
        ...

    # Mapping from particles to nodes (P2G)
    def compute_nodal_mass(self, particles: Particles):
        r&#34;&#34;&#34;Compute the nodal mass based on particle mass.

        The nodal mass is updated as a sum of particle mass for
        all particles mapped to the node.

        \[
            (m)_i = \sum_p N_i(x_p) m_p
        \]

        Parameters
        ----------
        particles: diffmpm.particle.Particles
            Particles to map to the nodal values.
        &#34;&#34;&#34;

        def _step(pid, args):
            pmass, mass, mapped_pos, el_nodes = args
            mass = mass.at[el_nodes[pid]].add(pmass[pid] * mapped_pos[pid])
            return pmass, mass, mapped_pos, el_nodes

        self.nodes.mass = self.nodes.mass.at[:].set(0)
        mapped_positions = self.shapefn(particles.reference_loc)
        mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
        args = (
            particles.mass,
            self.nodes.mass,
            mapped_positions,
            mapped_nodes,
        )
        _, self.nodes.mass, _, _ = lax.fori_loop(0, len(particles), _step, args)

    def compute_nodal_momentum(self, particles: Particles):
        r&#34;&#34;&#34;Compute the nodal mass based on particle mass.

        The nodal mass is updated as a sum of particle mass for
        all particles mapped to the node.

        \[
            (mv)_i = \sum_p N_i(x_p) (mv)_p
        \]

        Parameters
        ----------
        particles: diffmpm.particle.Particles
            Particles to map to the nodal values.
        &#34;&#34;&#34;

        def _step(pid, args):
            pmom, mom, mapped_pos, el_nodes = args
            mom = mom.at[el_nodes[pid]].add(mapped_pos[pid] @ pmom[pid])
            return pmom, mom, mapped_pos, el_nodes

        self.nodes.momentum = self.nodes.momentum.at[:].set(0)
        mapped_positions = self.shapefn(particles.reference_loc)
        mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
        args = (
            particles.mass * particles.velocity,
            self.nodes.momentum,
            mapped_positions,
            mapped_nodes,
        )
        _, self.nodes.momentum, _, _ = lax.fori_loop(0, len(particles), _step, args)
        self.nodes.momentum = jnp.where(
            jnp.abs(self.nodes.momentum) &lt; 1e-12,
            jnp.zeros_like(self.nodes.momentum),
            self.nodes.momentum,
        )

    def compute_velocity(self, particles: Particles):
        &#34;&#34;&#34;Compute velocity using momentum.&#34;&#34;&#34;
        self.nodes.velocity = jnp.where(
            self.nodes.mass == 0,
            self.nodes.velocity,
            self.nodes.momentum / self.nodes.mass,
        )
        self.nodes.velocity = jnp.where(
            jnp.abs(self.nodes.velocity) &lt; 1e-12,
            jnp.zeros_like(self.nodes.velocity),
            self.nodes.velocity,
        )

    def compute_external_force(self, particles: Particles):
        r&#34;&#34;&#34;Update the nodal external force based on particle f_ext.

        The nodal force is updated as a sum of particle external
        force for all particles mapped to the node.

        \[
            f_{ext})_i = \sum_p N_i(x_p) f_{ext}
        \]

        Parameters
        ----------
        particles: diffmpm.particle.Particles
            Particles to map to the nodal values.
        &#34;&#34;&#34;

        def _step(pid, args):
            f_ext, pf_ext, mapped_pos, el_nodes = args
            f_ext = f_ext.at[el_nodes[pid]].add(mapped_pos[pid] @ pf_ext[pid])
            return f_ext, pf_ext, mapped_pos, el_nodes

        self.nodes.f_ext = self.nodes.f_ext.at[:].set(0)
        mapped_positions = self.shapefn(particles.reference_loc)
        mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
        args = (
            self.nodes.f_ext,
            particles.f_ext,
            mapped_positions,
            mapped_nodes,
        )
        self.nodes.f_ext, _, _, _ = lax.fori_loop(0, len(particles), _step, args)

    def compute_body_force(self, particles: Particles, gravity: ArrayLike):
        r&#34;&#34;&#34;Update the nodal external force based on particle mass.

        The nodal force is updated as a sum of particle body
        force for all particles mapped to th

        \[
            (f_{ext})_i = (f_{ext})_i + \sum_p N_i(x_p) m_p g
        \]

        Parameters
        ----------
        particles: diffmpm.particle.Particles
            Particles to map to the nodal values.
        &#34;&#34;&#34;

        def _step(pid, args):
            f_ext, pmass, mapped_pos, el_nodes, gravity = args
            f_ext = f_ext.at[el_nodes[pid]].add(
                mapped_pos[pid] @ (pmass[pid] * gravity)
            )
            return f_ext, pmass, mapped_pos, el_nodes, gravity

        mapped_positions = self.shapefn(particles.reference_loc)
        mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
        args = (
            self.nodes.f_ext,
            particles.mass,
            mapped_positions,
            mapped_nodes,
            gravity,
        )
        self.nodes.f_ext, _, _, _, _ = lax.fori_loop(0, len(particles), _step, args)

    def apply_concentrated_nodal_forces(self, particles: Particles, curr_time: float):
        &#34;&#34;&#34;Apply concentrated nodal forces.

        Parameters
        ----------
        particles: Particles
            Particles in the simulation.
        curr_time: float
            Current time in the simulation.
        &#34;&#34;&#34;
        for cnf in self.concentrated_nodal_forces:
            factor = cnf.function.value(curr_time)
            self.nodes.f_ext = self.nodes.f_ext.at[cnf.node_ids, 0, cnf.dir].add(
                factor * cnf.force
            )

    def apply_particle_traction_forces(self, particles: Particles):
        &#34;&#34;&#34;Apply concentrated nodal forces.

        Parameters
        ----------
        particles: Particles
            Particles in the simulation.
        &#34;&#34;&#34;

        def _step(pid, args):
            f_ext, ptraction, mapped_pos, el_nodes = args
            f_ext = f_ext.at[el_nodes[pid]].add(mapped_pos[pid] @ ptraction[pid])
            return f_ext, ptraction, mapped_pos, el_nodes

        mapped_positions = self.shapefn(particles.reference_loc)
        mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
        args = (self.nodes.f_ext, particles.traction, mapped_positions, mapped_nodes)
        self.nodes.f_ext, _, _, _ = lax.fori_loop(0, len(particles), _step, args)

    def update_nodal_acceleration_velocity(
        self, particles: Particles, dt: float, *args
    ):
        &#34;&#34;&#34;Update the nodal momentum based on total force on nodes.&#34;&#34;&#34;
        total_force = self.nodes.get_total_force()
        self.nodes.acceleration = self.nodes.acceleration.at[:].set(
            jnp.nan_to_num(jnp.divide(total_force, self.nodes.mass))
        )
        self.nodes.velocity = self.nodes.velocity.at[:].add(
            self.nodes.acceleration * dt
        )
        self.apply_boundary_constraints()
        self.nodes.momentum = self.nodes.momentum.at[:].set(
            self.nodes.mass * self.nodes.velocity
        )
        self.nodes.velocity = jnp.where(
            jnp.abs(self.nodes.velocity) &lt; 1e-12,
            jnp.zeros_like(self.nodes.velocity),
            self.nodes.velocity,
        )
        self.nodes.acceleration = jnp.where(
            jnp.abs(self.nodes.acceleration) &lt; 1e-12,
            jnp.zeros_like(self.nodes.acceleration),
            self.nodes.acceleration,
        )

    def apply_boundary_constraints(self, *args):
        &#34;&#34;&#34;Apply boundary conditions for nodal velocity.&#34;&#34;&#34;
        for ids, constraint in self.constraints:
            constraint.apply(self.nodes, ids)

    def apply_force_boundary_constraints(self, *args):
        &#34;&#34;&#34;Apply boundary conditions for nodal forces.&#34;&#34;&#34;
        self.nodes.f_int = self.nodes.f_int.at[self.constraints[0][0]].set(0)
        self.nodes.f_ext = self.nodes.f_ext.at[self.constraints[0][0]].set(0)
        self.nodes.f_damp = self.nodes.f_damp.at[self.constraints[0][0]].set(0)


@register_pytree_node_class
class Linear1D(_Element):
    &#34;&#34;&#34;Container for 1D line elements (and nodes).

        Element ID:            0     1     2     3
        Mesh:               +-----+-----+-----+-----+
        Node IDs:           0     1     2     3     4

    where

        + : Nodes
        +-----+ : An element

    &#34;&#34;&#34;

    def __init__(
        self,
        nelements: int,
        total_elements: int,
        el_len: float,
        constraints: Sequence[Tuple[ArrayLike, Constraint]],
        nodes: Optional[Nodes] = None,
        concentrated_nodal_forces: Sequence = [],
        initialized: Optional[bool] = None,
        volume: Optional[ArrayLike] = None,
    ):
        &#34;&#34;&#34;Initialize Linear1D.

        Parameters
        ----------
        nelements : int
            Number of elements.
        total_elements : int
            Total number of elements (same as `nelements` for 1D)
        el_len : float
            Length of each element.
        constraints: list
            A list of constraints where each element is a tuple of type
            `(node_ids, diffmpm.Constraint)`. Here, `node_ids` correspond to
            the node IDs where `diffmpm.Constraint` should be applied.
        nodes : Nodes, Optional
            Nodes in the element object.
        concentrated_nodal_forces: list
            A list of `diffmpm.forces.NodalForce`s that are to be
            applied.
        initialized: bool, None
            `True` if the class has been initialized, `None` if not.
            This is required like this for using JAX flattening.
        volume: ArrayLike
            Volume of the elements.
        &#34;&#34;&#34;
        self.nelements = nelements
        self.total_elements = nelements
        self.el_len = el_len
        if nodes is None:
            self.nodes = Nodes(
                nelements + 1,
                jnp.arange(nelements + 1).reshape(-1, 1, 1) * el_len,
            )
        else:
            self.nodes = nodes

        # self.boundary_nodes = boundary_nodes
        self.constraints = constraints
        self.concentrated_nodal_forces = concentrated_nodal_forces
        if initialized is None:
            self.volume = jnp.ones((self.total_elements, 1, 1))
        else:
            self.volume = jnp.asarray(volume)
        self.initialized = True

    def id_to_node_ids(self, id: ArrayLike):
        &#34;&#34;&#34;Node IDs corresponding to element `id`.

        Parameters
        ----------
        id : int
            Element ID.

        Returns
        -------
        ArrayLike
            Nodal IDs of the element. Shape of returned
            array is `(2, 1)`
        &#34;&#34;&#34;
        return jnp.array([id, id + 1]).reshape(2, 1)

    def shapefn(self, xi: ArrayLike):
        &#34;&#34;&#34;Evaluate linear shape function.

        Parameters
        ----------
        xi : float, array_like
            Locations of particles in natural coordinates to evaluate
            the function at. Expected shape is `(npoints, 1, ndim)`

        Returns
        -------
        array_like
            Evaluated shape function values. The shape of the returned
            array will depend on the input shape. For example, in the linear
            case, if the input is a scalar, the returned array will be of
            the shape `(1, 2, 1)` but if the input is a vector then the output will
            be of the shape `(len(x), 2, 1)`.
        &#34;&#34;&#34;
        xi = jnp.asarray(xi)
        if xi.ndim != 3:
            raise ValueError(
                f&#34;`xi` should be of size (npoints, 1, ndim); found {xi.shape}&#34;
            )
        result = jnp.array([0.5 * (1 - xi), 0.5 * (1 + xi)]).transpose(1, 0, 2, 3)
        return result

    def _shapefn_natural_grad(self, xi: ArrayLike):
        &#34;&#34;&#34;Calculate the gradient of shape function.

        This calculation is done in the natural coordinates.

        Parameters
        ----------
        x : float, array_like
            Locations of particles in natural coordinates to evaluate
            the function at.

        Returns
        -------
        array_like
            Evaluated gradient values of the shape function. The shape of
            the returned array will depend on the input shape. For example,
            in the linear case, if the input is a scalar, the returned array
            will be of the shape `(2, 1)`.
        &#34;&#34;&#34;
        xi = jnp.asarray(xi)
        result = vmap(jacobian(self.shapefn))(xi[..., jnp.newaxis]).squeeze()

        # TODO: The following code tries to evaluate vmap even if
        # the predicate condition is true, not sure why.
        # result = lax.cond(
        #     jnp.isscalar(x),
        #     jacobian(self.shapefn),
        #     vmap(jacobian(self.shapefn)),
        #     xi
        # )
        return result.reshape(2, 1)

    def shapefn_grad(self, xi: ArrayLike, coords: ArrayLike):
        &#34;&#34;&#34;Gradient of shape function in physical coordinates.

        Parameters
        ----------
        xi : float, array_like
            Locations of particles to evaluate in natural coordinates.
            Expected shape `(npoints, 1, ndim)`.
        coords : array_like
            Nodal coordinates to transform by. Expected shape
            `(npoints, 1, ndim)`

        Returns
        -------
        array_like
            Gradient of the shape function in physical coordinates at `xi`
        &#34;&#34;&#34;
        xi = jnp.asarray(xi)
        coords = jnp.asarray(coords)
        if xi.ndim != 3:
            raise ValueError(
                f&#34;`x` should be of size (npoints, 1, ndim); found {xi.shape}&#34;
            )
        grad_sf = self._shapefn_natural_grad(xi)
        _jacobian = grad_sf.T @ coords

        result = grad_sf @ jnp.linalg.inv(_jacobian).T
        return result

    def set_particle_element_ids(self, particles):
        &#34;&#34;&#34;Set the element IDs for the particles.

        If the particle doesn&#39;t lie between the boundaries of any
        element, it sets the element index to -1.
        &#34;&#34;&#34;

        @jit
        def f(x):
            idl = (
                len(self.nodes.loc)
                - 1
                - jnp.asarray(self.nodes.loc[::-1] &lt;= x).nonzero(size=1, fill_value=-1)[
                    0
                ][-1]
            )
            idg = (
                jnp.asarray(self.nodes.loc &gt; x).nonzero(size=1, fill_value=-1)[0][0] - 1
            )
            return (idl, idg)

        ids = vmap(f)(particles.loc)
        particles.element_ids = jnp.where(
            ids[0] == ids[1], ids[0], jnp.ones_like(ids[0]) * -1
        )

    def compute_volume(self, *args):
        &#34;&#34;&#34;Compute volume of all elements.&#34;&#34;&#34;
        vol = jnp.ediff1d(self.nodes.loc)
        self.volume = jnp.ones((self.total_elements, 1, 1)) * vol

    def compute_internal_force(self, particles):
        r&#34;&#34;&#34;Update the nodal internal force based on particle mass.

        The nodal force is updated as a sum of internal forces for
        all particles mapped to the node.

        \[
            (f_{int})_i = -\sum_p V_p \sigma_p \nabla N_i(x_p)
        \]

        where \(\sigma_p\) is the stress at particle \(p\).

        Parameters
        ----------
        particles: diffmpm.particle.Particles
            Particles to map to the nodal values.
        &#34;&#34;&#34;

        def _step(pid, args):
            (
                f_int,
                pvol,
                mapped_grads,
                el_nodes,
                pstress,
            ) = args
            # TODO: correct matrix multiplication for n-d
            # update = -(pvol[pid]) * pstress[pid] @ mapped_grads[pid]
            update = -pvol[pid] * pstress[pid][0] * mapped_grads[pid]
            f_int = f_int.at[el_nodes[pid]].add(update[..., jnp.newaxis])
            return (
                f_int,
                pvol,
                mapped_grads,
                el_nodes,
                pstress,
            )

        self.nodes.f_int = self.nodes.f_int.at[:].set(0)
        mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
        mapped_coords = vmap(self.id_to_node_loc)(particles.element_ids).squeeze(2)
        mapped_grads = vmap(self.shapefn_grad)(
            particles.reference_loc[:, jnp.newaxis, ...],
            mapped_coords,
        )
        args = (
            self.nodes.f_int,
            particles.volume,
            mapped_grads,
            mapped_nodes,
            particles.stress,
        )
        self.nodes.f_int, _, _, _, _ = lax.fori_loop(0, len(particles), _step, args)


@register_pytree_node_class
class Quadrilateral4Node(_Element):
    r&#34;&#34;&#34;Container for 2D quadrilateral elements with 4 nodes.

    Nodes and elements are numbered as

                 15 +---+---+---+---+ 19
                    | 8 | 9 | 10| 11|
                 10 +---+---+---+---+ 14
                    | 4 | 5 | 6 | 7 |
                  5 +---+---+---+---+ 9
                    | 0 | 1 | 2 | 3 |
                    +---+---+---+---+
                    0   1   2   3   4

    where

            + : Nodes
            +---+
            |   | : An element
            +---+
    &#34;&#34;&#34;

    def __init__(
        self,
        nelements: int,
        total_elements: int,
        el_len: float,
        constraints: Sequence[Tuple[ArrayLike, Constraint]],
        nodes: Optional[Nodes] = None,
        concentrated_nodal_forces: Sequence = [],
        initialized: Optional[bool] = None,
        volume: Optional[ArrayLike] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize Linear1D.

        Parameters
        ----------
        nelements : int
            Number of elements.
        total_elements : int
            Total number of elements (product of all elements of `nelements`)
        el_len : float
            Length of each element.
        constraints: list
            A list of constraints where each element is a tuple of
            type `(node_ids, diffmpm.Constraint)`. Here, `node_ids`
            correspond to the node IDs where `diffmpm.Constraint`
            should be applied.
        nodes : Nodes, Optional
            Nodes in the element object.
        concentrated_nodal_forces: list
            A list of `diffmpm.forces.NodalForce`s that are to be
            applied.
        initialized: bool, None
            `True` if the class has been initialized, `None` if not.
            This is required like this for using JAX flattening.
        volume: ArrayLike
            Volume of the elements.
        &#34;&#34;&#34;
        self.nelements = jnp.asarray(nelements)
        self.el_len = jnp.asarray(el_len)
        self.total_elements = total_elements

        if nodes is None:
            total_nodes = jnp.prod(self.nelements + 1)
            coords = jnp.asarray(
                list(
                    itertools.product(
                        jnp.arange(self.nelements[1] + 1),
                        jnp.arange(self.nelements[0] + 1),
                    )
                )
            )
            node_locations = (
                jnp.asarray([coords[:, 1], coords[:, 0]]).T * self.el_len
            ).reshape(-1, 1, 2)
            self.nodes = Nodes(int(total_nodes), node_locations)
        else:
            self.nodes = nodes

        self.constraints = constraints
        self.concentrated_nodal_forces = concentrated_nodal_forces
        if initialized is None:
            self.volume = jnp.ones((self.total_elements, 1, 1))
        else:
            self.volume = jnp.asarray(volume)
        self.initialized = True

    def id_to_node_ids(self, id: ArrayLike):
        &#34;&#34;&#34;Node IDs corresponding to element `id`.

            3----2
            |    |
            0----1

        Node ids are returned in the order as shown in the figure.

        Parameters
        ----------
        id : int
            Element ID.

        Returns
        -------
        ArrayLike
            Nodal IDs of the element. Shape of returned
            array is (4, 1)
        &#34;&#34;&#34;
        lower_left = (id // self.nelements[0]) * (
            self.nelements[0] + 1
        ) + id % self.nelements[0]
        result = jnp.asarray(
            [
                lower_left,
                lower_left + 1,
                lower_left + self.nelements[0] + 2,
                lower_left + self.nelements[0] + 1,
            ]
        )
        return result.reshape(4, 1)

    def shapefn(self, xi: ArrayLike):
        &#34;&#34;&#34;Evaluate linear shape function.

        Parameters
        ----------
        xi : float, array_like
            Locations of particles in natural coordinates to evaluate
            the function at. Expected shape is (npoints, 1, ndim)

        Returns
        -------
        array_like
            Evaluated shape function values. The shape of the returned
            array will depend on the input shape. For example, in the linear
            case, if the input is a scalar, the returned array will be of
            the shape `(1, 4, 1)` but if the input is a vector then the output will
            be of the shape `(len(x), 4, 1)`.
        &#34;&#34;&#34;
        xi = jnp.asarray(xi)
        if xi.ndim != 3:
            raise ValueError(
                f&#34;`xi` should be of size (npoints, 1, ndim); found {xi.shape}&#34;
            )
        result = jnp.array(
            [
                0.25 * (1 - xi[:, :, 0]) * (1 - xi[:, :, 1]),
                0.25 * (1 + xi[:, :, 0]) * (1 - xi[:, :, 1]),
                0.25 * (1 + xi[:, :, 0]) * (1 + xi[:, :, 1]),
                0.25 * (1 - xi[:, :, 0]) * (1 + xi[:, :, 1]),
            ]
        )
        result = result.transpose(1, 0, 2)[..., jnp.newaxis]
        return result

    def _shapefn_natural_grad(self, xi: ArrayLike):
        &#34;&#34;&#34;Calculate the gradient of shape function.

        This calculation is done in the natural coordinates.

        Parameters
        ----------
        x : float, array_like
            Locations of particles in natural coordinates to evaluate
            the function at.

        Returns
        -------
        array_like
            Evaluated gradient values of the shape function. The shape of
            the returned array will depend on the input shape. For example,
            in the linear case, if the input is a scalar, the returned array
            will be of the shape `(4, 2)`.
        &#34;&#34;&#34;
        # result = vmap(jacobian(self.shapefn))(xi[..., jnp.newaxis]).squeeze()
        xi = jnp.asarray(xi)
        xi = xi.squeeze()
        result = jnp.array(
            [
                [-0.25 * (1 - xi[1]), -0.25 * (1 - xi[0])],
                [0.25 * (1 - xi[1]), -0.25 * (1 + xi[0])],
                [0.25 * (1 + xi[1]), 0.25 * (1 + xi[0])],
                [-0.25 * (1 + xi[1]), 0.25 * (1 - xi[0])],
            ],
        )
        return result

    def shapefn_grad(self, xi: ArrayLike, coords: ArrayLike):
        &#34;&#34;&#34;Gradient of shape function in physical coordinates.

        Parameters
        ----------
        xi : float, array_like
            Locations of particles to evaluate in natural coordinates.
            Expected shape `(npoints, 1, ndim)`.
        coords : array_like
            Nodal coordinates to transform by. Expected shape
            `(npoints, 1, ndim)`

        Returns
        -------
        array_like
            Gradient of the shape function in physical coordinates at `xi`
        &#34;&#34;&#34;
        xi = jnp.asarray(xi)
        coords = jnp.asarray(coords)
        if xi.ndim != 3:
            raise ValueError(
                f&#34;`x` should be of size (npoints, 1, ndim); found {xi.shape}&#34;
            )
        grad_sf = self._shapefn_natural_grad(xi)
        _jacobian = grad_sf.T @ coords.squeeze()

        result = grad_sf @ jnp.linalg.inv(_jacobian).T
        return result

    def set_particle_element_ids(self, particles: Particles):
        &#34;&#34;&#34;Set the element IDs for the particles.

        If the particle doesn&#39;t lie between the boundaries of any
        element, it sets the element index to -1.
        &#34;&#34;&#34;

        @jit
        def f(x):
            xidl = (self.nodes.loc[:, :, 0] &lt;= x[0, 0]).nonzero(
                size=len(self.nodes.loc), fill_value=-1
            )[0]
            yidl = (self.nodes.loc[:, :, 1] &lt;= x[0, 1]).nonzero(
                size=len(self.nodes.loc), fill_value=-1
            )[0]
            lower_left = jnp.where(jnp.isin(xidl, yidl), xidl, -1).max()
            element_id = lower_left - lower_left // (self.nelements[0] + 1)
            return element_id

        ids = vmap(f)(particles.loc)
        particles.element_ids = ids

    def compute_internal_force(self, particles: Particles):
        r&#34;&#34;&#34;Update the nodal internal force based on particle mass.

        The nodal force is updated as a sum of internal forces for
        all particles mapped to the node.

        \[
            (f_{int})_i = -\sum_p V_p \sigma_p \nabla N_i(x_p)
        \]

        where \(\sigma_p\) is the stress at particle \(p\).

        Parameters
        ----------
        particles: diffmpm.particle.Particles
            Particles to map to the nodal values.
        &#34;&#34;&#34;

        def _step(pid, args):
            (
                f_int,
                pvol,
                mapped_grads,
                el_nodes,
                pstress,
            ) = args
            force = jnp.zeros((mapped_grads.shape[1], 1, 2))
            force = force.at[:, 0, 0].set(
                mapped_grads[pid][:, 0] * pstress[pid][0]
                + mapped_grads[pid][:, 1] * pstress[pid][3]
            )
            force = force.at[:, 0, 1].set(
                mapped_grads[pid][:, 1] * pstress[pid][1]
                + mapped_grads[pid][:, 0] * pstress[pid][3]
            )
            update = -pvol[pid] * force
            f_int = f_int.at[el_nodes[pid]].add(update)
            return (
                f_int,
                pvol,
                mapped_grads,
                el_nodes,
                pstress,
            )

        self.nodes.f_int = self.nodes.f_int.at[:].set(0)
        mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
        mapped_coords = vmap(self.id_to_node_loc)(particles.element_ids).squeeze(2)
        mapped_grads = vmap(self.shapefn_grad)(
            particles.reference_loc[:, jnp.newaxis, ...],
            mapped_coords,
        )
        args = (
            self.nodes.f_int,
            particles.volume,
            mapped_grads,
            mapped_nodes,
            particles.stress,
        )
        self.nodes.f_int, _, _, _, _ = lax.fori_loop(0, len(particles), _step, args)

    def compute_volume(self, *args):
        &#34;&#34;&#34;Compute volume of all elements.&#34;&#34;&#34;
        a = c = self.el_len[1]
        b = d = self.el_len[0]
        p = q = jnp.sqrt(a**2 + b**2)
        vol = 0.25 * jnp.sqrt(4 * p * p * q * q - (a * a + c * c - b * b - d * d) ** 2)
        self.volume = self.volume.at[:].set(vol)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="diffmpm.element.Linear1D"><code class="flex name class">
<span>class <span class="ident">Linear1D</span></span>
<span>(</span><span>nelements: int, total_elements: int, el_len: float, constraints: Sequence[Tuple[ArrayLike, Constraint]], nodes: Optional[Nodes] = None, concentrated_nodal_forces: Sequence = [], initialized: Optional[bool] = None, volume: Optional[ArrayLike] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Container for 1D line elements (and nodes).</p>
<pre><code>Element ID:            0     1     2     3
Mesh:               +-----+-----+-----+-----+
Node IDs:           0     1     2     3     4
</code></pre>
<p>where</p>
<pre><code>+ : Nodes
+-----+ : An element
</code></pre>
<p>Initialize Linear1D.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nelements</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of elements.</dd>
<dt><strong><code>total_elements</code></strong> :&ensp;<code>int</code></dt>
<dd>Total number of elements (same as <code>nelements</code> for 1D)</dd>
<dt><strong><code>el_len</code></strong> :&ensp;<code>float</code></dt>
<dd>Length of each element.</dd>
<dt><strong><code>constraints</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of constraints where each element is a tuple of type
<code>(node_ids, diffmpm.Constraint)</code>. Here, <code>node_ids</code> correspond to
the node IDs where <code>diffmpm.Constraint</code> should be applied.</dd>
<dt><strong><code>nodes</code></strong> :&ensp;<code>Nodes, Optional</code></dt>
<dd>Nodes in the element object.</dd>
<dt><strong><code>concentrated_nodal_forces</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of <code><a title="diffmpm.forces.NodalForce" href="forces.html#diffmpm.forces.NodalForce">NodalForce</a></code>s that are to be
applied.</dd>
<dt><strong><code>initialized</code></strong> :&ensp;<code>bool, None</code></dt>
<dd><code>True</code> if the class has been initialized, <code>None</code> if not.
This is required like this for using JAX flattening.</dd>
<dt><strong><code>volume</code></strong> :&ensp;<code>ArrayLike</code></dt>
<dd>Volume of the elements.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@register_pytree_node_class
class Linear1D(_Element):
    &#34;&#34;&#34;Container for 1D line elements (and nodes).

        Element ID:            0     1     2     3
        Mesh:               +-----+-----+-----+-----+
        Node IDs:           0     1     2     3     4

    where

        + : Nodes
        +-----+ : An element

    &#34;&#34;&#34;

    def __init__(
        self,
        nelements: int,
        total_elements: int,
        el_len: float,
        constraints: Sequence[Tuple[ArrayLike, Constraint]],
        nodes: Optional[Nodes] = None,
        concentrated_nodal_forces: Sequence = [],
        initialized: Optional[bool] = None,
        volume: Optional[ArrayLike] = None,
    ):
        &#34;&#34;&#34;Initialize Linear1D.

        Parameters
        ----------
        nelements : int
            Number of elements.
        total_elements : int
            Total number of elements (same as `nelements` for 1D)
        el_len : float
            Length of each element.
        constraints: list
            A list of constraints where each element is a tuple of type
            `(node_ids, diffmpm.Constraint)`. Here, `node_ids` correspond to
            the node IDs where `diffmpm.Constraint` should be applied.
        nodes : Nodes, Optional
            Nodes in the element object.
        concentrated_nodal_forces: list
            A list of `diffmpm.forces.NodalForce`s that are to be
            applied.
        initialized: bool, None
            `True` if the class has been initialized, `None` if not.
            This is required like this for using JAX flattening.
        volume: ArrayLike
            Volume of the elements.
        &#34;&#34;&#34;
        self.nelements = nelements
        self.total_elements = nelements
        self.el_len = el_len
        if nodes is None:
            self.nodes = Nodes(
                nelements + 1,
                jnp.arange(nelements + 1).reshape(-1, 1, 1) * el_len,
            )
        else:
            self.nodes = nodes

        # self.boundary_nodes = boundary_nodes
        self.constraints = constraints
        self.concentrated_nodal_forces = concentrated_nodal_forces
        if initialized is None:
            self.volume = jnp.ones((self.total_elements, 1, 1))
        else:
            self.volume = jnp.asarray(volume)
        self.initialized = True

    def id_to_node_ids(self, id: ArrayLike):
        &#34;&#34;&#34;Node IDs corresponding to element `id`.

        Parameters
        ----------
        id : int
            Element ID.

        Returns
        -------
        ArrayLike
            Nodal IDs of the element. Shape of returned
            array is `(2, 1)`
        &#34;&#34;&#34;
        return jnp.array([id, id + 1]).reshape(2, 1)

    def shapefn(self, xi: ArrayLike):
        &#34;&#34;&#34;Evaluate linear shape function.

        Parameters
        ----------
        xi : float, array_like
            Locations of particles in natural coordinates to evaluate
            the function at. Expected shape is `(npoints, 1, ndim)`

        Returns
        -------
        array_like
            Evaluated shape function values. The shape of the returned
            array will depend on the input shape. For example, in the linear
            case, if the input is a scalar, the returned array will be of
            the shape `(1, 2, 1)` but if the input is a vector then the output will
            be of the shape `(len(x), 2, 1)`.
        &#34;&#34;&#34;
        xi = jnp.asarray(xi)
        if xi.ndim != 3:
            raise ValueError(
                f&#34;`xi` should be of size (npoints, 1, ndim); found {xi.shape}&#34;
            )
        result = jnp.array([0.5 * (1 - xi), 0.5 * (1 + xi)]).transpose(1, 0, 2, 3)
        return result

    def _shapefn_natural_grad(self, xi: ArrayLike):
        &#34;&#34;&#34;Calculate the gradient of shape function.

        This calculation is done in the natural coordinates.

        Parameters
        ----------
        x : float, array_like
            Locations of particles in natural coordinates to evaluate
            the function at.

        Returns
        -------
        array_like
            Evaluated gradient values of the shape function. The shape of
            the returned array will depend on the input shape. For example,
            in the linear case, if the input is a scalar, the returned array
            will be of the shape `(2, 1)`.
        &#34;&#34;&#34;
        xi = jnp.asarray(xi)
        result = vmap(jacobian(self.shapefn))(xi[..., jnp.newaxis]).squeeze()

        # TODO: The following code tries to evaluate vmap even if
        # the predicate condition is true, not sure why.
        # result = lax.cond(
        #     jnp.isscalar(x),
        #     jacobian(self.shapefn),
        #     vmap(jacobian(self.shapefn)),
        #     xi
        # )
        return result.reshape(2, 1)

    def shapefn_grad(self, xi: ArrayLike, coords: ArrayLike):
        &#34;&#34;&#34;Gradient of shape function in physical coordinates.

        Parameters
        ----------
        xi : float, array_like
            Locations of particles to evaluate in natural coordinates.
            Expected shape `(npoints, 1, ndim)`.
        coords : array_like
            Nodal coordinates to transform by. Expected shape
            `(npoints, 1, ndim)`

        Returns
        -------
        array_like
            Gradient of the shape function in physical coordinates at `xi`
        &#34;&#34;&#34;
        xi = jnp.asarray(xi)
        coords = jnp.asarray(coords)
        if xi.ndim != 3:
            raise ValueError(
                f&#34;`x` should be of size (npoints, 1, ndim); found {xi.shape}&#34;
            )
        grad_sf = self._shapefn_natural_grad(xi)
        _jacobian = grad_sf.T @ coords

        result = grad_sf @ jnp.linalg.inv(_jacobian).T
        return result

    def set_particle_element_ids(self, particles):
        &#34;&#34;&#34;Set the element IDs for the particles.

        If the particle doesn&#39;t lie between the boundaries of any
        element, it sets the element index to -1.
        &#34;&#34;&#34;

        @jit
        def f(x):
            idl = (
                len(self.nodes.loc)
                - 1
                - jnp.asarray(self.nodes.loc[::-1] &lt;= x).nonzero(size=1, fill_value=-1)[
                    0
                ][-1]
            )
            idg = (
                jnp.asarray(self.nodes.loc &gt; x).nonzero(size=1, fill_value=-1)[0][0] - 1
            )
            return (idl, idg)

        ids = vmap(f)(particles.loc)
        particles.element_ids = jnp.where(
            ids[0] == ids[1], ids[0], jnp.ones_like(ids[0]) * -1
        )

    def compute_volume(self, *args):
        &#34;&#34;&#34;Compute volume of all elements.&#34;&#34;&#34;
        vol = jnp.ediff1d(self.nodes.loc)
        self.volume = jnp.ones((self.total_elements, 1, 1)) * vol

    def compute_internal_force(self, particles):
        r&#34;&#34;&#34;Update the nodal internal force based on particle mass.

        The nodal force is updated as a sum of internal forces for
        all particles mapped to the node.

        \[
            (f_{int})_i = -\sum_p V_p \sigma_p \nabla N_i(x_p)
        \]

        where \(\sigma_p\) is the stress at particle \(p\).

        Parameters
        ----------
        particles: diffmpm.particle.Particles
            Particles to map to the nodal values.
        &#34;&#34;&#34;

        def _step(pid, args):
            (
                f_int,
                pvol,
                mapped_grads,
                el_nodes,
                pstress,
            ) = args
            # TODO: correct matrix multiplication for n-d
            # update = -(pvol[pid]) * pstress[pid] @ mapped_grads[pid]
            update = -pvol[pid] * pstress[pid][0] * mapped_grads[pid]
            f_int = f_int.at[el_nodes[pid]].add(update[..., jnp.newaxis])
            return (
                f_int,
                pvol,
                mapped_grads,
                el_nodes,
                pstress,
            )

        self.nodes.f_int = self.nodes.f_int.at[:].set(0)
        mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
        mapped_coords = vmap(self.id_to_node_loc)(particles.element_ids).squeeze(2)
        mapped_grads = vmap(self.shapefn_grad)(
            particles.reference_loc[:, jnp.newaxis, ...],
            mapped_coords,
        )
        args = (
            self.nodes.f_int,
            particles.volume,
            mapped_grads,
            mapped_nodes,
            particles.stress,
        )
        self.nodes.f_int, _, _, _, _ = lax.fori_loop(0, len(particles), _step, args)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="diffmpm.element._Element" href="#diffmpm.element._Element">_Element</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="diffmpm.element.Linear1D.compute_internal_force"><code class="name flex">
<span>def <span class="ident">compute_internal_force</span></span>(<span>self, particles)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the nodal internal force based on particle mass.</p>
<p>The nodal force is updated as a sum of internal forces for
all particles mapped to the node.</p>
<p><span><span class="MathJax_Preview">
(f_{int})_i = -\sum_p V_p \sigma_p \nabla N_i(x_p)
</span><script type="math/tex; mode=display">
(f_{int})_i = -\sum_p V_p \sigma_p \nabla N_i(x_p)
</script></span></p>
<p>where <span><span class="MathJax_Preview">\sigma_p</span><script type="math/tex">\sigma_p</script></span> is the stress at particle <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>particles</code></strong> :&ensp;<code><a title="diffmpm.particle.Particles" href="particle.html#diffmpm.particle.Particles">Particles</a></code></dt>
<dd>Particles to map to the nodal values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_internal_force(self, particles):
    r&#34;&#34;&#34;Update the nodal internal force based on particle mass.

    The nodal force is updated as a sum of internal forces for
    all particles mapped to the node.

    \[
        (f_{int})_i = -\sum_p V_p \sigma_p \nabla N_i(x_p)
    \]

    where \(\sigma_p\) is the stress at particle \(p\).

    Parameters
    ----------
    particles: diffmpm.particle.Particles
        Particles to map to the nodal values.
    &#34;&#34;&#34;

    def _step(pid, args):
        (
            f_int,
            pvol,
            mapped_grads,
            el_nodes,
            pstress,
        ) = args
        # TODO: correct matrix multiplication for n-d
        # update = -(pvol[pid]) * pstress[pid] @ mapped_grads[pid]
        update = -pvol[pid] * pstress[pid][0] * mapped_grads[pid]
        f_int = f_int.at[el_nodes[pid]].add(update[..., jnp.newaxis])
        return (
            f_int,
            pvol,
            mapped_grads,
            el_nodes,
            pstress,
        )

    self.nodes.f_int = self.nodes.f_int.at[:].set(0)
    mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
    mapped_coords = vmap(self.id_to_node_loc)(particles.element_ids).squeeze(2)
    mapped_grads = vmap(self.shapefn_grad)(
        particles.reference_loc[:, jnp.newaxis, ...],
        mapped_coords,
    )
    args = (
        self.nodes.f_int,
        particles.volume,
        mapped_grads,
        mapped_nodes,
        particles.stress,
    )
    self.nodes.f_int, _, _, _, _ = lax.fori_loop(0, len(particles), _step, args)</code></pre>
</details>
</dd>
<dt id="diffmpm.element.Linear1D.compute_volume"><code class="name flex">
<span>def <span class="ident">compute_volume</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute volume of all elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_volume(self, *args):
    &#34;&#34;&#34;Compute volume of all elements.&#34;&#34;&#34;
    vol = jnp.ediff1d(self.nodes.loc)
    self.volume = jnp.ones((self.total_elements, 1, 1)) * vol</code></pre>
</details>
</dd>
<dt id="diffmpm.element.Linear1D.id_to_node_ids"><code class="name flex">
<span>def <span class="ident">id_to_node_ids</span></span>(<span>self, id: ArrayLike)</span>
</code></dt>
<dd>
<div class="desc"><p>Node IDs corresponding to element <code>id</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code></dt>
<dd>Element ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ArrayLike</code></dt>
<dd>Nodal IDs of the element. Shape of returned
array is <code>(2, 1)</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_to_node_ids(self, id: ArrayLike):
    &#34;&#34;&#34;Node IDs corresponding to element `id`.

    Parameters
    ----------
    id : int
        Element ID.

    Returns
    -------
    ArrayLike
        Nodal IDs of the element. Shape of returned
        array is `(2, 1)`
    &#34;&#34;&#34;
    return jnp.array([id, id + 1]).reshape(2, 1)</code></pre>
</details>
</dd>
<dt id="diffmpm.element.Linear1D.set_particle_element_ids"><code class="name flex">
<span>def <span class="ident">set_particle_element_ids</span></span>(<span>self, particles)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the element IDs for the particles.</p>
<p>If the particle doesn't lie between the boundaries of any
element, it sets the element index to -1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_particle_element_ids(self, particles):
    &#34;&#34;&#34;Set the element IDs for the particles.

    If the particle doesn&#39;t lie between the boundaries of any
    element, it sets the element index to -1.
    &#34;&#34;&#34;

    @jit
    def f(x):
        idl = (
            len(self.nodes.loc)
            - 1
            - jnp.asarray(self.nodes.loc[::-1] &lt;= x).nonzero(size=1, fill_value=-1)[
                0
            ][-1]
        )
        idg = (
            jnp.asarray(self.nodes.loc &gt; x).nonzero(size=1, fill_value=-1)[0][0] - 1
        )
        return (idl, idg)

    ids = vmap(f)(particles.loc)
    particles.element_ids = jnp.where(
        ids[0] == ids[1], ids[0], jnp.ones_like(ids[0]) * -1
    )</code></pre>
</details>
</dd>
<dt id="diffmpm.element.Linear1D.shapefn"><code class="name flex">
<span>def <span class="ident">shapefn</span></span>(<span>self, xi: ArrayLike)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate linear shape function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xi</code></strong> :&ensp;<code>float, array_like</code></dt>
<dd>Locations of particles in natural coordinates to evaluate
the function at. Expected shape is <code>(npoints, 1, ndim)</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>array_like</code></dt>
<dd>Evaluated shape function values. The shape of the returned
array will depend on the input shape. For example, in the linear
case, if the input is a scalar, the returned array will be of
the shape <code>(1, 2, 1)</code> but if the input is a vector then the output will
be of the shape <code>(len(x), 2, 1)</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shapefn(self, xi: ArrayLike):
    &#34;&#34;&#34;Evaluate linear shape function.

    Parameters
    ----------
    xi : float, array_like
        Locations of particles in natural coordinates to evaluate
        the function at. Expected shape is `(npoints, 1, ndim)`

    Returns
    -------
    array_like
        Evaluated shape function values. The shape of the returned
        array will depend on the input shape. For example, in the linear
        case, if the input is a scalar, the returned array will be of
        the shape `(1, 2, 1)` but if the input is a vector then the output will
        be of the shape `(len(x), 2, 1)`.
    &#34;&#34;&#34;
    xi = jnp.asarray(xi)
    if xi.ndim != 3:
        raise ValueError(
            f&#34;`xi` should be of size (npoints, 1, ndim); found {xi.shape}&#34;
        )
    result = jnp.array([0.5 * (1 - xi), 0.5 * (1 + xi)]).transpose(1, 0, 2, 3)
    return result</code></pre>
</details>
</dd>
<dt id="diffmpm.element.Linear1D.shapefn_grad"><code class="name flex">
<span>def <span class="ident">shapefn_grad</span></span>(<span>self, xi: ArrayLike, coords: ArrayLike)</span>
</code></dt>
<dd>
<div class="desc"><p>Gradient of shape function in physical coordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xi</code></strong> :&ensp;<code>float, array_like</code></dt>
<dd>Locations of particles to evaluate in natural coordinates.
Expected shape <code>(npoints, 1, ndim)</code>.</dd>
<dt><strong><code>coords</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Nodal coordinates to transform by. Expected shape
<code>(npoints, 1, ndim)</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>array_like</code></dt>
<dd>Gradient of the shape function in physical coordinates at <code>xi</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shapefn_grad(self, xi: ArrayLike, coords: ArrayLike):
    &#34;&#34;&#34;Gradient of shape function in physical coordinates.

    Parameters
    ----------
    xi : float, array_like
        Locations of particles to evaluate in natural coordinates.
        Expected shape `(npoints, 1, ndim)`.
    coords : array_like
        Nodal coordinates to transform by. Expected shape
        `(npoints, 1, ndim)`

    Returns
    -------
    array_like
        Gradient of the shape function in physical coordinates at `xi`
    &#34;&#34;&#34;
    xi = jnp.asarray(xi)
    coords = jnp.asarray(coords)
    if xi.ndim != 3:
        raise ValueError(
            f&#34;`x` should be of size (npoints, 1, ndim); found {xi.shape}&#34;
        )
    grad_sf = self._shapefn_natural_grad(xi)
    _jacobian = grad_sf.T @ coords

    result = grad_sf @ jnp.linalg.inv(_jacobian).T
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="diffmpm.element._Element" href="#diffmpm.element._Element">_Element</a></b></code>:
<ul class="hlist">
<li><code><a title="diffmpm.element._Element.apply_boundary_constraints" href="#diffmpm.element._Element.apply_boundary_constraints">apply_boundary_constraints</a></code></li>
<li><code><a title="diffmpm.element._Element.apply_concentrated_nodal_forces" href="#diffmpm.element._Element.apply_concentrated_nodal_forces">apply_concentrated_nodal_forces</a></code></li>
<li><code><a title="diffmpm.element._Element.apply_force_boundary_constraints" href="#diffmpm.element._Element.apply_force_boundary_constraints">apply_force_boundary_constraints</a></code></li>
<li><code><a title="diffmpm.element._Element.apply_particle_traction_forces" href="#diffmpm.element._Element.apply_particle_traction_forces">apply_particle_traction_forces</a></code></li>
<li><code><a title="diffmpm.element._Element.compute_body_force" href="#diffmpm.element._Element.compute_body_force">compute_body_force</a></code></li>
<li><code><a title="diffmpm.element._Element.compute_external_force" href="#diffmpm.element._Element.compute_external_force">compute_external_force</a></code></li>
<li><code><a title="diffmpm.element._Element.compute_nodal_mass" href="#diffmpm.element._Element.compute_nodal_mass">compute_nodal_mass</a></code></li>
<li><code><a title="diffmpm.element._Element.compute_nodal_momentum" href="#diffmpm.element._Element.compute_nodal_momentum">compute_nodal_momentum</a></code></li>
<li><code><a title="diffmpm.element._Element.compute_velocity" href="#diffmpm.element._Element.compute_velocity">compute_velocity</a></code></li>
<li><code><a title="diffmpm.element._Element.id_to_node_loc" href="#diffmpm.element._Element.id_to_node_loc">id_to_node_loc</a></code></li>
<li><code><a title="diffmpm.element._Element.id_to_node_vel" href="#diffmpm.element._Element.id_to_node_vel">id_to_node_vel</a></code></li>
<li><code><a title="diffmpm.element._Element.update_nodal_acceleration_velocity" href="#diffmpm.element._Element.update_nodal_acceleration_velocity">update_nodal_acceleration_velocity</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="diffmpm.element.Quadrilateral4Node"><code class="flex name class">
<span>class <span class="ident">Quadrilateral4Node</span></span>
<span>(</span><span>nelements: int, total_elements: int, el_len: float, constraints: Sequence[Tuple[ArrayLike, Constraint]], nodes: Optional[Nodes] = None, concentrated_nodal_forces: Sequence = [], initialized: Optional[bool] = None, volume: Optional[ArrayLike] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Container for 2D quadrilateral elements with 4 nodes.</p>
<p>Nodes and elements are numbered as</p>
<pre><code>         15 +---+---+---+---+ 19
            | 8 | 9 | 10| 11|
         10 +---+---+---+---+ 14
            | 4 | 5 | 6 | 7 |
          5 +---+---+---+---+ 9
            | 0 | 1 | 2 | 3 |
            +---+---+---+---+
            0   1   2   3   4
</code></pre>
<p>where</p>
<pre><code>    + : Nodes
    +---+
    |   | : An element
    +---+
</code></pre>
<p>Initialize Linear1D.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nelements</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of elements.</dd>
<dt><strong><code>total_elements</code></strong> :&ensp;<code>int</code></dt>
<dd>Total number of elements (product of all elements of <code>nelements</code>)</dd>
<dt><strong><code>el_len</code></strong> :&ensp;<code>float</code></dt>
<dd>Length of each element.</dd>
<dt><strong><code>constraints</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of constraints where each element is a tuple of
type <code>(node_ids, diffmpm.Constraint)</code>. Here, <code>node_ids</code>
correspond to the node IDs where <code>diffmpm.Constraint</code>
should be applied.</dd>
<dt><strong><code>nodes</code></strong> :&ensp;<code>Nodes, Optional</code></dt>
<dd>Nodes in the element object.</dd>
<dt><strong><code>concentrated_nodal_forces</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of <code><a title="diffmpm.forces.NodalForce" href="forces.html#diffmpm.forces.NodalForce">NodalForce</a></code>s that are to be
applied.</dd>
<dt><strong><code>initialized</code></strong> :&ensp;<code>bool, None</code></dt>
<dd><code>True</code> if the class has been initialized, <code>None</code> if not.
This is required like this for using JAX flattening.</dd>
<dt><strong><code>volume</code></strong> :&ensp;<code>ArrayLike</code></dt>
<dd>Volume of the elements.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@register_pytree_node_class
class Quadrilateral4Node(_Element):
    r&#34;&#34;&#34;Container for 2D quadrilateral elements with 4 nodes.

    Nodes and elements are numbered as

                 15 +---+---+---+---+ 19
                    | 8 | 9 | 10| 11|
                 10 +---+---+---+---+ 14
                    | 4 | 5 | 6 | 7 |
                  5 +---+---+---+---+ 9
                    | 0 | 1 | 2 | 3 |
                    +---+---+---+---+
                    0   1   2   3   4

    where

            + : Nodes
            +---+
            |   | : An element
            +---+
    &#34;&#34;&#34;

    def __init__(
        self,
        nelements: int,
        total_elements: int,
        el_len: float,
        constraints: Sequence[Tuple[ArrayLike, Constraint]],
        nodes: Optional[Nodes] = None,
        concentrated_nodal_forces: Sequence = [],
        initialized: Optional[bool] = None,
        volume: Optional[ArrayLike] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize Linear1D.

        Parameters
        ----------
        nelements : int
            Number of elements.
        total_elements : int
            Total number of elements (product of all elements of `nelements`)
        el_len : float
            Length of each element.
        constraints: list
            A list of constraints where each element is a tuple of
            type `(node_ids, diffmpm.Constraint)`. Here, `node_ids`
            correspond to the node IDs where `diffmpm.Constraint`
            should be applied.
        nodes : Nodes, Optional
            Nodes in the element object.
        concentrated_nodal_forces: list
            A list of `diffmpm.forces.NodalForce`s that are to be
            applied.
        initialized: bool, None
            `True` if the class has been initialized, `None` if not.
            This is required like this for using JAX flattening.
        volume: ArrayLike
            Volume of the elements.
        &#34;&#34;&#34;
        self.nelements = jnp.asarray(nelements)
        self.el_len = jnp.asarray(el_len)
        self.total_elements = total_elements

        if nodes is None:
            total_nodes = jnp.prod(self.nelements + 1)
            coords = jnp.asarray(
                list(
                    itertools.product(
                        jnp.arange(self.nelements[1] + 1),
                        jnp.arange(self.nelements[0] + 1),
                    )
                )
            )
            node_locations = (
                jnp.asarray([coords[:, 1], coords[:, 0]]).T * self.el_len
            ).reshape(-1, 1, 2)
            self.nodes = Nodes(int(total_nodes), node_locations)
        else:
            self.nodes = nodes

        self.constraints = constraints
        self.concentrated_nodal_forces = concentrated_nodal_forces
        if initialized is None:
            self.volume = jnp.ones((self.total_elements, 1, 1))
        else:
            self.volume = jnp.asarray(volume)
        self.initialized = True

    def id_to_node_ids(self, id: ArrayLike):
        &#34;&#34;&#34;Node IDs corresponding to element `id`.

            3----2
            |    |
            0----1

        Node ids are returned in the order as shown in the figure.

        Parameters
        ----------
        id : int
            Element ID.

        Returns
        -------
        ArrayLike
            Nodal IDs of the element. Shape of returned
            array is (4, 1)
        &#34;&#34;&#34;
        lower_left = (id // self.nelements[0]) * (
            self.nelements[0] + 1
        ) + id % self.nelements[0]
        result = jnp.asarray(
            [
                lower_left,
                lower_left + 1,
                lower_left + self.nelements[0] + 2,
                lower_left + self.nelements[0] + 1,
            ]
        )
        return result.reshape(4, 1)

    def shapefn(self, xi: ArrayLike):
        &#34;&#34;&#34;Evaluate linear shape function.

        Parameters
        ----------
        xi : float, array_like
            Locations of particles in natural coordinates to evaluate
            the function at. Expected shape is (npoints, 1, ndim)

        Returns
        -------
        array_like
            Evaluated shape function values. The shape of the returned
            array will depend on the input shape. For example, in the linear
            case, if the input is a scalar, the returned array will be of
            the shape `(1, 4, 1)` but if the input is a vector then the output will
            be of the shape `(len(x), 4, 1)`.
        &#34;&#34;&#34;
        xi = jnp.asarray(xi)
        if xi.ndim != 3:
            raise ValueError(
                f&#34;`xi` should be of size (npoints, 1, ndim); found {xi.shape}&#34;
            )
        result = jnp.array(
            [
                0.25 * (1 - xi[:, :, 0]) * (1 - xi[:, :, 1]),
                0.25 * (1 + xi[:, :, 0]) * (1 - xi[:, :, 1]),
                0.25 * (1 + xi[:, :, 0]) * (1 + xi[:, :, 1]),
                0.25 * (1 - xi[:, :, 0]) * (1 + xi[:, :, 1]),
            ]
        )
        result = result.transpose(1, 0, 2)[..., jnp.newaxis]
        return result

    def _shapefn_natural_grad(self, xi: ArrayLike):
        &#34;&#34;&#34;Calculate the gradient of shape function.

        This calculation is done in the natural coordinates.

        Parameters
        ----------
        x : float, array_like
            Locations of particles in natural coordinates to evaluate
            the function at.

        Returns
        -------
        array_like
            Evaluated gradient values of the shape function. The shape of
            the returned array will depend on the input shape. For example,
            in the linear case, if the input is a scalar, the returned array
            will be of the shape `(4, 2)`.
        &#34;&#34;&#34;
        # result = vmap(jacobian(self.shapefn))(xi[..., jnp.newaxis]).squeeze()
        xi = jnp.asarray(xi)
        xi = xi.squeeze()
        result = jnp.array(
            [
                [-0.25 * (1 - xi[1]), -0.25 * (1 - xi[0])],
                [0.25 * (1 - xi[1]), -0.25 * (1 + xi[0])],
                [0.25 * (1 + xi[1]), 0.25 * (1 + xi[0])],
                [-0.25 * (1 + xi[1]), 0.25 * (1 - xi[0])],
            ],
        )
        return result

    def shapefn_grad(self, xi: ArrayLike, coords: ArrayLike):
        &#34;&#34;&#34;Gradient of shape function in physical coordinates.

        Parameters
        ----------
        xi : float, array_like
            Locations of particles to evaluate in natural coordinates.
            Expected shape `(npoints, 1, ndim)`.
        coords : array_like
            Nodal coordinates to transform by. Expected shape
            `(npoints, 1, ndim)`

        Returns
        -------
        array_like
            Gradient of the shape function in physical coordinates at `xi`
        &#34;&#34;&#34;
        xi = jnp.asarray(xi)
        coords = jnp.asarray(coords)
        if xi.ndim != 3:
            raise ValueError(
                f&#34;`x` should be of size (npoints, 1, ndim); found {xi.shape}&#34;
            )
        grad_sf = self._shapefn_natural_grad(xi)
        _jacobian = grad_sf.T @ coords.squeeze()

        result = grad_sf @ jnp.linalg.inv(_jacobian).T
        return result

    def set_particle_element_ids(self, particles: Particles):
        &#34;&#34;&#34;Set the element IDs for the particles.

        If the particle doesn&#39;t lie between the boundaries of any
        element, it sets the element index to -1.
        &#34;&#34;&#34;

        @jit
        def f(x):
            xidl = (self.nodes.loc[:, :, 0] &lt;= x[0, 0]).nonzero(
                size=len(self.nodes.loc), fill_value=-1
            )[0]
            yidl = (self.nodes.loc[:, :, 1] &lt;= x[0, 1]).nonzero(
                size=len(self.nodes.loc), fill_value=-1
            )[0]
            lower_left = jnp.where(jnp.isin(xidl, yidl), xidl, -1).max()
            element_id = lower_left - lower_left // (self.nelements[0] + 1)
            return element_id

        ids = vmap(f)(particles.loc)
        particles.element_ids = ids

    def compute_internal_force(self, particles: Particles):
        r&#34;&#34;&#34;Update the nodal internal force based on particle mass.

        The nodal force is updated as a sum of internal forces for
        all particles mapped to the node.

        \[
            (f_{int})_i = -\sum_p V_p \sigma_p \nabla N_i(x_p)
        \]

        where \(\sigma_p\) is the stress at particle \(p\).

        Parameters
        ----------
        particles: diffmpm.particle.Particles
            Particles to map to the nodal values.
        &#34;&#34;&#34;

        def _step(pid, args):
            (
                f_int,
                pvol,
                mapped_grads,
                el_nodes,
                pstress,
            ) = args
            force = jnp.zeros((mapped_grads.shape[1], 1, 2))
            force = force.at[:, 0, 0].set(
                mapped_grads[pid][:, 0] * pstress[pid][0]
                + mapped_grads[pid][:, 1] * pstress[pid][3]
            )
            force = force.at[:, 0, 1].set(
                mapped_grads[pid][:, 1] * pstress[pid][1]
                + mapped_grads[pid][:, 0] * pstress[pid][3]
            )
            update = -pvol[pid] * force
            f_int = f_int.at[el_nodes[pid]].add(update)
            return (
                f_int,
                pvol,
                mapped_grads,
                el_nodes,
                pstress,
            )

        self.nodes.f_int = self.nodes.f_int.at[:].set(0)
        mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
        mapped_coords = vmap(self.id_to_node_loc)(particles.element_ids).squeeze(2)
        mapped_grads = vmap(self.shapefn_grad)(
            particles.reference_loc[:, jnp.newaxis, ...],
            mapped_coords,
        )
        args = (
            self.nodes.f_int,
            particles.volume,
            mapped_grads,
            mapped_nodes,
            particles.stress,
        )
        self.nodes.f_int, _, _, _, _ = lax.fori_loop(0, len(particles), _step, args)

    def compute_volume(self, *args):
        &#34;&#34;&#34;Compute volume of all elements.&#34;&#34;&#34;
        a = c = self.el_len[1]
        b = d = self.el_len[0]
        p = q = jnp.sqrt(a**2 + b**2)
        vol = 0.25 * jnp.sqrt(4 * p * p * q * q - (a * a + c * c - b * b - d * d) ** 2)
        self.volume = self.volume.at[:].set(vol)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="diffmpm.element._Element" href="#diffmpm.element._Element">_Element</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="diffmpm.element.Quadrilateral4Node.compute_internal_force"><code class="name flex">
<span>def <span class="ident">compute_internal_force</span></span>(<span>self, particles: Particles)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the nodal internal force based on particle mass.</p>
<p>The nodal force is updated as a sum of internal forces for
all particles mapped to the node.</p>
<p><span><span class="MathJax_Preview">
(f_{int})_i = -\sum_p V_p \sigma_p \nabla N_i(x_p)
</span><script type="math/tex; mode=display">
(f_{int})_i = -\sum_p V_p \sigma_p \nabla N_i(x_p)
</script></span></p>
<p>where <span><span class="MathJax_Preview">\sigma_p</span><script type="math/tex">\sigma_p</script></span> is the stress at particle <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>particles</code></strong> :&ensp;<code><a title="diffmpm.particle.Particles" href="particle.html#diffmpm.particle.Particles">Particles</a></code></dt>
<dd>Particles to map to the nodal values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_internal_force(self, particles: Particles):
    r&#34;&#34;&#34;Update the nodal internal force based on particle mass.

    The nodal force is updated as a sum of internal forces for
    all particles mapped to the node.

    \[
        (f_{int})_i = -\sum_p V_p \sigma_p \nabla N_i(x_p)
    \]

    where \(\sigma_p\) is the stress at particle \(p\).

    Parameters
    ----------
    particles: diffmpm.particle.Particles
        Particles to map to the nodal values.
    &#34;&#34;&#34;

    def _step(pid, args):
        (
            f_int,
            pvol,
            mapped_grads,
            el_nodes,
            pstress,
        ) = args
        force = jnp.zeros((mapped_grads.shape[1], 1, 2))
        force = force.at[:, 0, 0].set(
            mapped_grads[pid][:, 0] * pstress[pid][0]
            + mapped_grads[pid][:, 1] * pstress[pid][3]
        )
        force = force.at[:, 0, 1].set(
            mapped_grads[pid][:, 1] * pstress[pid][1]
            + mapped_grads[pid][:, 0] * pstress[pid][3]
        )
        update = -pvol[pid] * force
        f_int = f_int.at[el_nodes[pid]].add(update)
        return (
            f_int,
            pvol,
            mapped_grads,
            el_nodes,
            pstress,
        )

    self.nodes.f_int = self.nodes.f_int.at[:].set(0)
    mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
    mapped_coords = vmap(self.id_to_node_loc)(particles.element_ids).squeeze(2)
    mapped_grads = vmap(self.shapefn_grad)(
        particles.reference_loc[:, jnp.newaxis, ...],
        mapped_coords,
    )
    args = (
        self.nodes.f_int,
        particles.volume,
        mapped_grads,
        mapped_nodes,
        particles.stress,
    )
    self.nodes.f_int, _, _, _, _ = lax.fori_loop(0, len(particles), _step, args)</code></pre>
</details>
</dd>
<dt id="diffmpm.element.Quadrilateral4Node.compute_volume"><code class="name flex">
<span>def <span class="ident">compute_volume</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute volume of all elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_volume(self, *args):
    &#34;&#34;&#34;Compute volume of all elements.&#34;&#34;&#34;
    a = c = self.el_len[1]
    b = d = self.el_len[0]
    p = q = jnp.sqrt(a**2 + b**2)
    vol = 0.25 * jnp.sqrt(4 * p * p * q * q - (a * a + c * c - b * b - d * d) ** 2)
    self.volume = self.volume.at[:].set(vol)</code></pre>
</details>
</dd>
<dt id="diffmpm.element.Quadrilateral4Node.id_to_node_ids"><code class="name flex">
<span>def <span class="ident">id_to_node_ids</span></span>(<span>self, id: ArrayLike)</span>
</code></dt>
<dd>
<div class="desc"><p>Node IDs corresponding to element <code>id</code>.</p>
<pre><code>3----2
|    |
0----1
</code></pre>
<p>Node ids are returned in the order as shown in the figure.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code></dt>
<dd>Element ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ArrayLike</code></dt>
<dd>Nodal IDs of the element. Shape of returned
array is (4, 1)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_to_node_ids(self, id: ArrayLike):
    &#34;&#34;&#34;Node IDs corresponding to element `id`.

        3----2
        |    |
        0----1

    Node ids are returned in the order as shown in the figure.

    Parameters
    ----------
    id : int
        Element ID.

    Returns
    -------
    ArrayLike
        Nodal IDs of the element. Shape of returned
        array is (4, 1)
    &#34;&#34;&#34;
    lower_left = (id // self.nelements[0]) * (
        self.nelements[0] + 1
    ) + id % self.nelements[0]
    result = jnp.asarray(
        [
            lower_left,
            lower_left + 1,
            lower_left + self.nelements[0] + 2,
            lower_left + self.nelements[0] + 1,
        ]
    )
    return result.reshape(4, 1)</code></pre>
</details>
</dd>
<dt id="diffmpm.element.Quadrilateral4Node.set_particle_element_ids"><code class="name flex">
<span>def <span class="ident">set_particle_element_ids</span></span>(<span>self, particles: Particles)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the element IDs for the particles.</p>
<p>If the particle doesn't lie between the boundaries of any
element, it sets the element index to -1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_particle_element_ids(self, particles: Particles):
    &#34;&#34;&#34;Set the element IDs for the particles.

    If the particle doesn&#39;t lie between the boundaries of any
    element, it sets the element index to -1.
    &#34;&#34;&#34;

    @jit
    def f(x):
        xidl = (self.nodes.loc[:, :, 0] &lt;= x[0, 0]).nonzero(
            size=len(self.nodes.loc), fill_value=-1
        )[0]
        yidl = (self.nodes.loc[:, :, 1] &lt;= x[0, 1]).nonzero(
            size=len(self.nodes.loc), fill_value=-1
        )[0]
        lower_left = jnp.where(jnp.isin(xidl, yidl), xidl, -1).max()
        element_id = lower_left - lower_left // (self.nelements[0] + 1)
        return element_id

    ids = vmap(f)(particles.loc)
    particles.element_ids = ids</code></pre>
</details>
</dd>
<dt id="diffmpm.element.Quadrilateral4Node.shapefn"><code class="name flex">
<span>def <span class="ident">shapefn</span></span>(<span>self, xi: ArrayLike)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate linear shape function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xi</code></strong> :&ensp;<code>float, array_like</code></dt>
<dd>Locations of particles in natural coordinates to evaluate
the function at. Expected shape is (npoints, 1, ndim)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>array_like</code></dt>
<dd>Evaluated shape function values. The shape of the returned
array will depend on the input shape. For example, in the linear
case, if the input is a scalar, the returned array will be of
the shape <code>(1, 4, 1)</code> but if the input is a vector then the output will
be of the shape <code>(len(x), 4, 1)</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shapefn(self, xi: ArrayLike):
    &#34;&#34;&#34;Evaluate linear shape function.

    Parameters
    ----------
    xi : float, array_like
        Locations of particles in natural coordinates to evaluate
        the function at. Expected shape is (npoints, 1, ndim)

    Returns
    -------
    array_like
        Evaluated shape function values. The shape of the returned
        array will depend on the input shape. For example, in the linear
        case, if the input is a scalar, the returned array will be of
        the shape `(1, 4, 1)` but if the input is a vector then the output will
        be of the shape `(len(x), 4, 1)`.
    &#34;&#34;&#34;
    xi = jnp.asarray(xi)
    if xi.ndim != 3:
        raise ValueError(
            f&#34;`xi` should be of size (npoints, 1, ndim); found {xi.shape}&#34;
        )
    result = jnp.array(
        [
            0.25 * (1 - xi[:, :, 0]) * (1 - xi[:, :, 1]),
            0.25 * (1 + xi[:, :, 0]) * (1 - xi[:, :, 1]),
            0.25 * (1 + xi[:, :, 0]) * (1 + xi[:, :, 1]),
            0.25 * (1 - xi[:, :, 0]) * (1 + xi[:, :, 1]),
        ]
    )
    result = result.transpose(1, 0, 2)[..., jnp.newaxis]
    return result</code></pre>
</details>
</dd>
<dt id="diffmpm.element.Quadrilateral4Node.shapefn_grad"><code class="name flex">
<span>def <span class="ident">shapefn_grad</span></span>(<span>self, xi: ArrayLike, coords: ArrayLike)</span>
</code></dt>
<dd>
<div class="desc"><p>Gradient of shape function in physical coordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xi</code></strong> :&ensp;<code>float, array_like</code></dt>
<dd>Locations of particles to evaluate in natural coordinates.
Expected shape <code>(npoints, 1, ndim)</code>.</dd>
<dt><strong><code>coords</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Nodal coordinates to transform by. Expected shape
<code>(npoints, 1, ndim)</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>array_like</code></dt>
<dd>Gradient of the shape function in physical coordinates at <code>xi</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shapefn_grad(self, xi: ArrayLike, coords: ArrayLike):
    &#34;&#34;&#34;Gradient of shape function in physical coordinates.

    Parameters
    ----------
    xi : float, array_like
        Locations of particles to evaluate in natural coordinates.
        Expected shape `(npoints, 1, ndim)`.
    coords : array_like
        Nodal coordinates to transform by. Expected shape
        `(npoints, 1, ndim)`

    Returns
    -------
    array_like
        Gradient of the shape function in physical coordinates at `xi`
    &#34;&#34;&#34;
    xi = jnp.asarray(xi)
    coords = jnp.asarray(coords)
    if xi.ndim != 3:
        raise ValueError(
            f&#34;`x` should be of size (npoints, 1, ndim); found {xi.shape}&#34;
        )
    grad_sf = self._shapefn_natural_grad(xi)
    _jacobian = grad_sf.T @ coords.squeeze()

    result = grad_sf @ jnp.linalg.inv(_jacobian).T
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="diffmpm.element._Element" href="#diffmpm.element._Element">_Element</a></b></code>:
<ul class="hlist">
<li><code><a title="diffmpm.element._Element.apply_boundary_constraints" href="#diffmpm.element._Element.apply_boundary_constraints">apply_boundary_constraints</a></code></li>
<li><code><a title="diffmpm.element._Element.apply_concentrated_nodal_forces" href="#diffmpm.element._Element.apply_concentrated_nodal_forces">apply_concentrated_nodal_forces</a></code></li>
<li><code><a title="diffmpm.element._Element.apply_force_boundary_constraints" href="#diffmpm.element._Element.apply_force_boundary_constraints">apply_force_boundary_constraints</a></code></li>
<li><code><a title="diffmpm.element._Element.apply_particle_traction_forces" href="#diffmpm.element._Element.apply_particle_traction_forces">apply_particle_traction_forces</a></code></li>
<li><code><a title="diffmpm.element._Element.compute_body_force" href="#diffmpm.element._Element.compute_body_force">compute_body_force</a></code></li>
<li><code><a title="diffmpm.element._Element.compute_external_force" href="#diffmpm.element._Element.compute_external_force">compute_external_force</a></code></li>
<li><code><a title="diffmpm.element._Element.compute_nodal_mass" href="#diffmpm.element._Element.compute_nodal_mass">compute_nodal_mass</a></code></li>
<li><code><a title="diffmpm.element._Element.compute_nodal_momentum" href="#diffmpm.element._Element.compute_nodal_momentum">compute_nodal_momentum</a></code></li>
<li><code><a title="diffmpm.element._Element.compute_velocity" href="#diffmpm.element._Element.compute_velocity">compute_velocity</a></code></li>
<li><code><a title="diffmpm.element._Element.id_to_node_loc" href="#diffmpm.element._Element.id_to_node_loc">id_to_node_loc</a></code></li>
<li><code><a title="diffmpm.element._Element.id_to_node_vel" href="#diffmpm.element._Element.id_to_node_vel">id_to_node_vel</a></code></li>
<li><code><a title="diffmpm.element._Element.update_nodal_acceleration_velocity" href="#diffmpm.element._Element.update_nodal_acceleration_velocity">update_nodal_acceleration_velocity</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="diffmpm.element._Element"><code class="flex name class">
<span>class <span class="ident">_Element</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base element class that is inherited by all types of Elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class _Element(abc.ABC):
    &#34;&#34;&#34;Base element class that is inherited by all types of Elements.&#34;&#34;&#34;

    nodes: Nodes
    total_elements: int
    concentrated_nodal_forces: Sequence
    volume: Array

    @abc.abstractmethod
    def id_to_node_ids(self, id: ArrayLike) -&gt; Array:
        &#34;&#34;&#34;Node IDs corresponding to element `id`.

        This method is implemented by each of the subclass.

        Parameters
        ----------
        id : int
            Element ID.

        Returns
        -------
        ArrayLike
            Nodal IDs of the element.
        &#34;&#34;&#34;
        ...

    def id_to_node_loc(self, id: ArrayLike) -&gt; Array:
        &#34;&#34;&#34;Node locations corresponding to element `id`.

        Parameters
        ----------
        id : int
            Element ID.

        Returns
        -------
        ArrayLike
            Nodal locations for the element. Shape of returned
            array is `(nodes_in_element, 1, ndim)`
        &#34;&#34;&#34;
        node_ids = self.id_to_node_ids(id).squeeze()
        return self.nodes.loc[node_ids]

    def id_to_node_vel(self, id: ArrayLike) -&gt; Array:
        &#34;&#34;&#34;Node velocities corresponding to element `id`.

        Parameters
        ----------
        id : int
            Element ID.

        Returns
        -------
        ArrayLike
            Nodal velocities for the element. Shape of returned
            array is `(nodes_in_element, 1, ndim)`
        &#34;&#34;&#34;
        node_ids = self.id_to_node_ids(id).squeeze()
        return self.nodes.velocity[node_ids]

    def tree_flatten(self):
        children = (self.nodes, self.volume)
        aux_data = (
            self.nelements,
            self.total_elements,
            self.el_len,
            self.constraints,
            self.concentrated_nodal_forces,
            self.initialized,
        )
        return children, aux_data

    @classmethod
    def tree_unflatten(cls, aux_data, children):
        return cls(
            aux_data[0],
            aux_data[1],
            aux_data[2],
            aux_data[3],
            nodes=children[0],
            concentrated_nodal_forces=aux_data[4],
            initialized=aux_data[5],
            volume=children[1],
        )

    @abc.abstractmethod
    def shapefn(self, xi: ArrayLike):
        &#34;&#34;&#34;Evaluate Shape function for element type.&#34;&#34;&#34;
        ...

    @abc.abstractmethod
    def shapefn_grad(self, xi: ArrayLike, coords: ArrayLike):
        &#34;&#34;&#34;Evaluate gradient of shape function for element type.&#34;&#34;&#34;
        ...

    @abc.abstractmethod
    def set_particle_element_ids(self, particles: Particles):
        &#34;&#34;&#34;Set the element IDs that particles are present in.&#34;&#34;&#34;
        ...

    # Mapping from particles to nodes (P2G)
    def compute_nodal_mass(self, particles: Particles):
        r&#34;&#34;&#34;Compute the nodal mass based on particle mass.

        The nodal mass is updated as a sum of particle mass for
        all particles mapped to the node.

        \[
            (m)_i = \sum_p N_i(x_p) m_p
        \]

        Parameters
        ----------
        particles: diffmpm.particle.Particles
            Particles to map to the nodal values.
        &#34;&#34;&#34;

        def _step(pid, args):
            pmass, mass, mapped_pos, el_nodes = args
            mass = mass.at[el_nodes[pid]].add(pmass[pid] * mapped_pos[pid])
            return pmass, mass, mapped_pos, el_nodes

        self.nodes.mass = self.nodes.mass.at[:].set(0)
        mapped_positions = self.shapefn(particles.reference_loc)
        mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
        args = (
            particles.mass,
            self.nodes.mass,
            mapped_positions,
            mapped_nodes,
        )
        _, self.nodes.mass, _, _ = lax.fori_loop(0, len(particles), _step, args)

    def compute_nodal_momentum(self, particles: Particles):
        r&#34;&#34;&#34;Compute the nodal mass based on particle mass.

        The nodal mass is updated as a sum of particle mass for
        all particles mapped to the node.

        \[
            (mv)_i = \sum_p N_i(x_p) (mv)_p
        \]

        Parameters
        ----------
        particles: diffmpm.particle.Particles
            Particles to map to the nodal values.
        &#34;&#34;&#34;

        def _step(pid, args):
            pmom, mom, mapped_pos, el_nodes = args
            mom = mom.at[el_nodes[pid]].add(mapped_pos[pid] @ pmom[pid])
            return pmom, mom, mapped_pos, el_nodes

        self.nodes.momentum = self.nodes.momentum.at[:].set(0)
        mapped_positions = self.shapefn(particles.reference_loc)
        mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
        args = (
            particles.mass * particles.velocity,
            self.nodes.momentum,
            mapped_positions,
            mapped_nodes,
        )
        _, self.nodes.momentum, _, _ = lax.fori_loop(0, len(particles), _step, args)
        self.nodes.momentum = jnp.where(
            jnp.abs(self.nodes.momentum) &lt; 1e-12,
            jnp.zeros_like(self.nodes.momentum),
            self.nodes.momentum,
        )

    def compute_velocity(self, particles: Particles):
        &#34;&#34;&#34;Compute velocity using momentum.&#34;&#34;&#34;
        self.nodes.velocity = jnp.where(
            self.nodes.mass == 0,
            self.nodes.velocity,
            self.nodes.momentum / self.nodes.mass,
        )
        self.nodes.velocity = jnp.where(
            jnp.abs(self.nodes.velocity) &lt; 1e-12,
            jnp.zeros_like(self.nodes.velocity),
            self.nodes.velocity,
        )

    def compute_external_force(self, particles: Particles):
        r&#34;&#34;&#34;Update the nodal external force based on particle f_ext.

        The nodal force is updated as a sum of particle external
        force for all particles mapped to the node.

        \[
            f_{ext})_i = \sum_p N_i(x_p) f_{ext}
        \]

        Parameters
        ----------
        particles: diffmpm.particle.Particles
            Particles to map to the nodal values.
        &#34;&#34;&#34;

        def _step(pid, args):
            f_ext, pf_ext, mapped_pos, el_nodes = args
            f_ext = f_ext.at[el_nodes[pid]].add(mapped_pos[pid] @ pf_ext[pid])
            return f_ext, pf_ext, mapped_pos, el_nodes

        self.nodes.f_ext = self.nodes.f_ext.at[:].set(0)
        mapped_positions = self.shapefn(particles.reference_loc)
        mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
        args = (
            self.nodes.f_ext,
            particles.f_ext,
            mapped_positions,
            mapped_nodes,
        )
        self.nodes.f_ext, _, _, _ = lax.fori_loop(0, len(particles), _step, args)

    def compute_body_force(self, particles: Particles, gravity: ArrayLike):
        r&#34;&#34;&#34;Update the nodal external force based on particle mass.

        The nodal force is updated as a sum of particle body
        force for all particles mapped to th

        \[
            (f_{ext})_i = (f_{ext})_i + \sum_p N_i(x_p) m_p g
        \]

        Parameters
        ----------
        particles: diffmpm.particle.Particles
            Particles to map to the nodal values.
        &#34;&#34;&#34;

        def _step(pid, args):
            f_ext, pmass, mapped_pos, el_nodes, gravity = args
            f_ext = f_ext.at[el_nodes[pid]].add(
                mapped_pos[pid] @ (pmass[pid] * gravity)
            )
            return f_ext, pmass, mapped_pos, el_nodes, gravity

        mapped_positions = self.shapefn(particles.reference_loc)
        mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
        args = (
            self.nodes.f_ext,
            particles.mass,
            mapped_positions,
            mapped_nodes,
            gravity,
        )
        self.nodes.f_ext, _, _, _, _ = lax.fori_loop(0, len(particles), _step, args)

    def apply_concentrated_nodal_forces(self, particles: Particles, curr_time: float):
        &#34;&#34;&#34;Apply concentrated nodal forces.

        Parameters
        ----------
        particles: Particles
            Particles in the simulation.
        curr_time: float
            Current time in the simulation.
        &#34;&#34;&#34;
        for cnf in self.concentrated_nodal_forces:
            factor = cnf.function.value(curr_time)
            self.nodes.f_ext = self.nodes.f_ext.at[cnf.node_ids, 0, cnf.dir].add(
                factor * cnf.force
            )

    def apply_particle_traction_forces(self, particles: Particles):
        &#34;&#34;&#34;Apply concentrated nodal forces.

        Parameters
        ----------
        particles: Particles
            Particles in the simulation.
        &#34;&#34;&#34;

        def _step(pid, args):
            f_ext, ptraction, mapped_pos, el_nodes = args
            f_ext = f_ext.at[el_nodes[pid]].add(mapped_pos[pid] @ ptraction[pid])
            return f_ext, ptraction, mapped_pos, el_nodes

        mapped_positions = self.shapefn(particles.reference_loc)
        mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
        args = (self.nodes.f_ext, particles.traction, mapped_positions, mapped_nodes)
        self.nodes.f_ext, _, _, _ = lax.fori_loop(0, len(particles), _step, args)

    def update_nodal_acceleration_velocity(
        self, particles: Particles, dt: float, *args
    ):
        &#34;&#34;&#34;Update the nodal momentum based on total force on nodes.&#34;&#34;&#34;
        total_force = self.nodes.get_total_force()
        self.nodes.acceleration = self.nodes.acceleration.at[:].set(
            jnp.nan_to_num(jnp.divide(total_force, self.nodes.mass))
        )
        self.nodes.velocity = self.nodes.velocity.at[:].add(
            self.nodes.acceleration * dt
        )
        self.apply_boundary_constraints()
        self.nodes.momentum = self.nodes.momentum.at[:].set(
            self.nodes.mass * self.nodes.velocity
        )
        self.nodes.velocity = jnp.where(
            jnp.abs(self.nodes.velocity) &lt; 1e-12,
            jnp.zeros_like(self.nodes.velocity),
            self.nodes.velocity,
        )
        self.nodes.acceleration = jnp.where(
            jnp.abs(self.nodes.acceleration) &lt; 1e-12,
            jnp.zeros_like(self.nodes.acceleration),
            self.nodes.acceleration,
        )

    def apply_boundary_constraints(self, *args):
        &#34;&#34;&#34;Apply boundary conditions for nodal velocity.&#34;&#34;&#34;
        for ids, constraint in self.constraints:
            constraint.apply(self.nodes, ids)

    def apply_force_boundary_constraints(self, *args):
        &#34;&#34;&#34;Apply boundary conditions for nodal forces.&#34;&#34;&#34;
        self.nodes.f_int = self.nodes.f_int.at[self.constraints[0][0]].set(0)
        self.nodes.f_ext = self.nodes.f_ext.at[self.constraints[0][0]].set(0)
        self.nodes.f_damp = self.nodes.f_damp.at[self.constraints[0][0]].set(0)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="diffmpm.element.Linear1D" href="#diffmpm.element.Linear1D">Linear1D</a></li>
<li><a title="diffmpm.element.Quadrilateral4Node" href="#diffmpm.element.Quadrilateral4Node">Quadrilateral4Node</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="diffmpm.element._Element.concentrated_nodal_forces"><code class="name">var <span class="ident">concentrated_nodal_forces</span> : Sequence</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="diffmpm.element._Element.nodes"><code class="name">var <span class="ident">nodes</span> : <a title="diffmpm.node.Nodes" href="node.html#diffmpm.node.Nodes">Nodes</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="diffmpm.element._Element.total_elements"><code class="name">var <span class="ident">total_elements</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="diffmpm.element._Element.volume"><code class="name">var <span class="ident">volume</span> : jax.Array</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="diffmpm.element._Element.tree_unflatten"><code class="name flex">
<span>def <span class="ident">tree_unflatten</span></span>(<span>aux_data, children)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def tree_unflatten(cls, aux_data, children):
    return cls(
        aux_data[0],
        aux_data[1],
        aux_data[2],
        aux_data[3],
        nodes=children[0],
        concentrated_nodal_forces=aux_data[4],
        initialized=aux_data[5],
        volume=children[1],
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="diffmpm.element._Element.apply_boundary_constraints"><code class="name flex">
<span>def <span class="ident">apply_boundary_constraints</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply boundary conditions for nodal velocity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_boundary_constraints(self, *args):
    &#34;&#34;&#34;Apply boundary conditions for nodal velocity.&#34;&#34;&#34;
    for ids, constraint in self.constraints:
        constraint.apply(self.nodes, ids)</code></pre>
</details>
</dd>
<dt id="diffmpm.element._Element.apply_concentrated_nodal_forces"><code class="name flex">
<span>def <span class="ident">apply_concentrated_nodal_forces</span></span>(<span>self, particles: Particles, curr_time: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply concentrated nodal forces.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>particles</code></strong> :&ensp;<code>Particles</code></dt>
<dd>Particles in the simulation.</dd>
<dt><strong><code>curr_time</code></strong> :&ensp;<code>float</code></dt>
<dd>Current time in the simulation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_concentrated_nodal_forces(self, particles: Particles, curr_time: float):
    &#34;&#34;&#34;Apply concentrated nodal forces.

    Parameters
    ----------
    particles: Particles
        Particles in the simulation.
    curr_time: float
        Current time in the simulation.
    &#34;&#34;&#34;
    for cnf in self.concentrated_nodal_forces:
        factor = cnf.function.value(curr_time)
        self.nodes.f_ext = self.nodes.f_ext.at[cnf.node_ids, 0, cnf.dir].add(
            factor * cnf.force
        )</code></pre>
</details>
</dd>
<dt id="diffmpm.element._Element.apply_force_boundary_constraints"><code class="name flex">
<span>def <span class="ident">apply_force_boundary_constraints</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply boundary conditions for nodal forces.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_force_boundary_constraints(self, *args):
    &#34;&#34;&#34;Apply boundary conditions for nodal forces.&#34;&#34;&#34;
    self.nodes.f_int = self.nodes.f_int.at[self.constraints[0][0]].set(0)
    self.nodes.f_ext = self.nodes.f_ext.at[self.constraints[0][0]].set(0)
    self.nodes.f_damp = self.nodes.f_damp.at[self.constraints[0][0]].set(0)</code></pre>
</details>
</dd>
<dt id="diffmpm.element._Element.apply_particle_traction_forces"><code class="name flex">
<span>def <span class="ident">apply_particle_traction_forces</span></span>(<span>self, particles: Particles)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply concentrated nodal forces.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>particles</code></strong> :&ensp;<code>Particles</code></dt>
<dd>Particles in the simulation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_particle_traction_forces(self, particles: Particles):
    &#34;&#34;&#34;Apply concentrated nodal forces.

    Parameters
    ----------
    particles: Particles
        Particles in the simulation.
    &#34;&#34;&#34;

    def _step(pid, args):
        f_ext, ptraction, mapped_pos, el_nodes = args
        f_ext = f_ext.at[el_nodes[pid]].add(mapped_pos[pid] @ ptraction[pid])
        return f_ext, ptraction, mapped_pos, el_nodes

    mapped_positions = self.shapefn(particles.reference_loc)
    mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
    args = (self.nodes.f_ext, particles.traction, mapped_positions, mapped_nodes)
    self.nodes.f_ext, _, _, _ = lax.fori_loop(0, len(particles), _step, args)</code></pre>
</details>
</dd>
<dt id="diffmpm.element._Element.compute_body_force"><code class="name flex">
<span>def <span class="ident">compute_body_force</span></span>(<span>self, particles: Particles, gravity: ArrayLike)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the nodal external force based on particle mass.</p>
<p>The nodal force is updated as a sum of particle body
force for all particles mapped to th</p>
<p><span><span class="MathJax_Preview">
(f_{ext})_i = (f_{ext})_i + \sum_p N_i(x_p) m_p g
</span><script type="math/tex; mode=display">
(f_{ext})_i = (f_{ext})_i + \sum_p N_i(x_p) m_p g
</script></span></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>particles</code></strong> :&ensp;<code><a title="diffmpm.particle.Particles" href="particle.html#diffmpm.particle.Particles">Particles</a></code></dt>
<dd>Particles to map to the nodal values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_body_force(self, particles: Particles, gravity: ArrayLike):
    r&#34;&#34;&#34;Update the nodal external force based on particle mass.

    The nodal force is updated as a sum of particle body
    force for all particles mapped to th

    \[
        (f_{ext})_i = (f_{ext})_i + \sum_p N_i(x_p) m_p g
    \]

    Parameters
    ----------
    particles: diffmpm.particle.Particles
        Particles to map to the nodal values.
    &#34;&#34;&#34;

    def _step(pid, args):
        f_ext, pmass, mapped_pos, el_nodes, gravity = args
        f_ext = f_ext.at[el_nodes[pid]].add(
            mapped_pos[pid] @ (pmass[pid] * gravity)
        )
        return f_ext, pmass, mapped_pos, el_nodes, gravity

    mapped_positions = self.shapefn(particles.reference_loc)
    mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
    args = (
        self.nodes.f_ext,
        particles.mass,
        mapped_positions,
        mapped_nodes,
        gravity,
    )
    self.nodes.f_ext, _, _, _, _ = lax.fori_loop(0, len(particles), _step, args)</code></pre>
</details>
</dd>
<dt id="diffmpm.element._Element.compute_external_force"><code class="name flex">
<span>def <span class="ident">compute_external_force</span></span>(<span>self, particles: Particles)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the nodal external force based on particle f_ext.</p>
<p>The nodal force is updated as a sum of particle external
force for all particles mapped to the node.</p>
<p><span><span class="MathJax_Preview">
f_{ext})_i = \sum_p N_i(x_p) f_{ext}
</span><script type="math/tex; mode=display">
f_{ext})_i = \sum_p N_i(x_p) f_{ext}
</script></span></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>particles</code></strong> :&ensp;<code><a title="diffmpm.particle.Particles" href="particle.html#diffmpm.particle.Particles">Particles</a></code></dt>
<dd>Particles to map to the nodal values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_external_force(self, particles: Particles):
    r&#34;&#34;&#34;Update the nodal external force based on particle f_ext.

    The nodal force is updated as a sum of particle external
    force for all particles mapped to the node.

    \[
        f_{ext})_i = \sum_p N_i(x_p) f_{ext}
    \]

    Parameters
    ----------
    particles: diffmpm.particle.Particles
        Particles to map to the nodal values.
    &#34;&#34;&#34;

    def _step(pid, args):
        f_ext, pf_ext, mapped_pos, el_nodes = args
        f_ext = f_ext.at[el_nodes[pid]].add(mapped_pos[pid] @ pf_ext[pid])
        return f_ext, pf_ext, mapped_pos, el_nodes

    self.nodes.f_ext = self.nodes.f_ext.at[:].set(0)
    mapped_positions = self.shapefn(particles.reference_loc)
    mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
    args = (
        self.nodes.f_ext,
        particles.f_ext,
        mapped_positions,
        mapped_nodes,
    )
    self.nodes.f_ext, _, _, _ = lax.fori_loop(0, len(particles), _step, args)</code></pre>
</details>
</dd>
<dt id="diffmpm.element._Element.compute_nodal_mass"><code class="name flex">
<span>def <span class="ident">compute_nodal_mass</span></span>(<span>self, particles: Particles)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the nodal mass based on particle mass.</p>
<p>The nodal mass is updated as a sum of particle mass for
all particles mapped to the node.</p>
<p><span><span class="MathJax_Preview">
(m)_i = \sum_p N_i(x_p) m_p
</span><script type="math/tex; mode=display">
(m)_i = \sum_p N_i(x_p) m_p
</script></span></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>particles</code></strong> :&ensp;<code><a title="diffmpm.particle.Particles" href="particle.html#diffmpm.particle.Particles">Particles</a></code></dt>
<dd>Particles to map to the nodal values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_nodal_mass(self, particles: Particles):
    r&#34;&#34;&#34;Compute the nodal mass based on particle mass.

    The nodal mass is updated as a sum of particle mass for
    all particles mapped to the node.

    \[
        (m)_i = \sum_p N_i(x_p) m_p
    \]

    Parameters
    ----------
    particles: diffmpm.particle.Particles
        Particles to map to the nodal values.
    &#34;&#34;&#34;

    def _step(pid, args):
        pmass, mass, mapped_pos, el_nodes = args
        mass = mass.at[el_nodes[pid]].add(pmass[pid] * mapped_pos[pid])
        return pmass, mass, mapped_pos, el_nodes

    self.nodes.mass = self.nodes.mass.at[:].set(0)
    mapped_positions = self.shapefn(particles.reference_loc)
    mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
    args = (
        particles.mass,
        self.nodes.mass,
        mapped_positions,
        mapped_nodes,
    )
    _, self.nodes.mass, _, _ = lax.fori_loop(0, len(particles), _step, args)</code></pre>
</details>
</dd>
<dt id="diffmpm.element._Element.compute_nodal_momentum"><code class="name flex">
<span>def <span class="ident">compute_nodal_momentum</span></span>(<span>self, particles: Particles)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the nodal mass based on particle mass.</p>
<p>The nodal mass is updated as a sum of particle mass for
all particles mapped to the node.</p>
<p><span><span class="MathJax_Preview">
(mv)_i = \sum_p N_i(x_p) (mv)_p
</span><script type="math/tex; mode=display">
(mv)_i = \sum_p N_i(x_p) (mv)_p
</script></span></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>particles</code></strong> :&ensp;<code><a title="diffmpm.particle.Particles" href="particle.html#diffmpm.particle.Particles">Particles</a></code></dt>
<dd>Particles to map to the nodal values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_nodal_momentum(self, particles: Particles):
    r&#34;&#34;&#34;Compute the nodal mass based on particle mass.

    The nodal mass is updated as a sum of particle mass for
    all particles mapped to the node.

    \[
        (mv)_i = \sum_p N_i(x_p) (mv)_p
    \]

    Parameters
    ----------
    particles: diffmpm.particle.Particles
        Particles to map to the nodal values.
    &#34;&#34;&#34;

    def _step(pid, args):
        pmom, mom, mapped_pos, el_nodes = args
        mom = mom.at[el_nodes[pid]].add(mapped_pos[pid] @ pmom[pid])
        return pmom, mom, mapped_pos, el_nodes

    self.nodes.momentum = self.nodes.momentum.at[:].set(0)
    mapped_positions = self.shapefn(particles.reference_loc)
    mapped_nodes = vmap(self.id_to_node_ids)(particles.element_ids).squeeze(-1)
    args = (
        particles.mass * particles.velocity,
        self.nodes.momentum,
        mapped_positions,
        mapped_nodes,
    )
    _, self.nodes.momentum, _, _ = lax.fori_loop(0, len(particles), _step, args)
    self.nodes.momentum = jnp.where(
        jnp.abs(self.nodes.momentum) &lt; 1e-12,
        jnp.zeros_like(self.nodes.momentum),
        self.nodes.momentum,
    )</code></pre>
</details>
</dd>
<dt id="diffmpm.element._Element.compute_velocity"><code class="name flex">
<span>def <span class="ident">compute_velocity</span></span>(<span>self, particles: Particles)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute velocity using momentum.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_velocity(self, particles: Particles):
    &#34;&#34;&#34;Compute velocity using momentum.&#34;&#34;&#34;
    self.nodes.velocity = jnp.where(
        self.nodes.mass == 0,
        self.nodes.velocity,
        self.nodes.momentum / self.nodes.mass,
    )
    self.nodes.velocity = jnp.where(
        jnp.abs(self.nodes.velocity) &lt; 1e-12,
        jnp.zeros_like(self.nodes.velocity),
        self.nodes.velocity,
    )</code></pre>
</details>
</dd>
<dt id="diffmpm.element._Element.id_to_node_ids"><code class="name flex">
<span>def <span class="ident">id_to_node_ids</span></span>(<span>self, id: ArrayLike) ‑> jax.Array</span>
</code></dt>
<dd>
<div class="desc"><p>Node IDs corresponding to element <code>id</code>.</p>
<p>This method is implemented by each of the subclass.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code></dt>
<dd>Element ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ArrayLike</code></dt>
<dd>Nodal IDs of the element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def id_to_node_ids(self, id: ArrayLike) -&gt; Array:
    &#34;&#34;&#34;Node IDs corresponding to element `id`.

    This method is implemented by each of the subclass.

    Parameters
    ----------
    id : int
        Element ID.

    Returns
    -------
    ArrayLike
        Nodal IDs of the element.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="diffmpm.element._Element.id_to_node_loc"><code class="name flex">
<span>def <span class="ident">id_to_node_loc</span></span>(<span>self, id: ArrayLike) ‑> jax.Array</span>
</code></dt>
<dd>
<div class="desc"><p>Node locations corresponding to element <code>id</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code></dt>
<dd>Element ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ArrayLike</code></dt>
<dd>Nodal locations for the element. Shape of returned
array is <code>(nodes_in_element, 1, ndim)</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_to_node_loc(self, id: ArrayLike) -&gt; Array:
    &#34;&#34;&#34;Node locations corresponding to element `id`.

    Parameters
    ----------
    id : int
        Element ID.

    Returns
    -------
    ArrayLike
        Nodal locations for the element. Shape of returned
        array is `(nodes_in_element, 1, ndim)`
    &#34;&#34;&#34;
    node_ids = self.id_to_node_ids(id).squeeze()
    return self.nodes.loc[node_ids]</code></pre>
</details>
</dd>
<dt id="diffmpm.element._Element.id_to_node_vel"><code class="name flex">
<span>def <span class="ident">id_to_node_vel</span></span>(<span>self, id: ArrayLike) ‑> jax.Array</span>
</code></dt>
<dd>
<div class="desc"><p>Node velocities corresponding to element <code>id</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code></dt>
<dd>Element ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ArrayLike</code></dt>
<dd>Nodal velocities for the element. Shape of returned
array is <code>(nodes_in_element, 1, ndim)</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_to_node_vel(self, id: ArrayLike) -&gt; Array:
    &#34;&#34;&#34;Node velocities corresponding to element `id`.

    Parameters
    ----------
    id : int
        Element ID.

    Returns
    -------
    ArrayLike
        Nodal velocities for the element. Shape of returned
        array is `(nodes_in_element, 1, ndim)`
    &#34;&#34;&#34;
    node_ids = self.id_to_node_ids(id).squeeze()
    return self.nodes.velocity[node_ids]</code></pre>
</details>
</dd>
<dt id="diffmpm.element._Element.set_particle_element_ids"><code class="name flex">
<span>def <span class="ident">set_particle_element_ids</span></span>(<span>self, particles: Particles)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the element IDs that particles are present in.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def set_particle_element_ids(self, particles: Particles):
    &#34;&#34;&#34;Set the element IDs that particles are present in.&#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="diffmpm.element._Element.shapefn"><code class="name flex">
<span>def <span class="ident">shapefn</span></span>(<span>self, xi: ArrayLike)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate Shape function for element type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def shapefn(self, xi: ArrayLike):
    &#34;&#34;&#34;Evaluate Shape function for element type.&#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="diffmpm.element._Element.shapefn_grad"><code class="name flex">
<span>def <span class="ident">shapefn_grad</span></span>(<span>self, xi: ArrayLike, coords: ArrayLike)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate gradient of shape function for element type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def shapefn_grad(self, xi: ArrayLike, coords: ArrayLike):
    &#34;&#34;&#34;Evaluate gradient of shape function for element type.&#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="diffmpm.element._Element.tree_flatten"><code class="name flex">
<span>def <span class="ident">tree_flatten</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tree_flatten(self):
    children = (self.nodes, self.volume)
    aux_data = (
        self.nelements,
        self.total_elements,
        self.el_len,
        self.constraints,
        self.concentrated_nodal_forces,
        self.initialized,
    )
    return children, aux_data</code></pre>
</details>
</dd>
<dt id="diffmpm.element._Element.update_nodal_acceleration_velocity"><code class="name flex">
<span>def <span class="ident">update_nodal_acceleration_velocity</span></span>(<span>self, particles: Particles, dt: float, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the nodal momentum based on total force on nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_nodal_acceleration_velocity(
    self, particles: Particles, dt: float, *args
):
    &#34;&#34;&#34;Update the nodal momentum based on total force on nodes.&#34;&#34;&#34;
    total_force = self.nodes.get_total_force()
    self.nodes.acceleration = self.nodes.acceleration.at[:].set(
        jnp.nan_to_num(jnp.divide(total_force, self.nodes.mass))
    )
    self.nodes.velocity = self.nodes.velocity.at[:].add(
        self.nodes.acceleration * dt
    )
    self.apply_boundary_constraints()
    self.nodes.momentum = self.nodes.momentum.at[:].set(
        self.nodes.mass * self.nodes.velocity
    )
    self.nodes.velocity = jnp.where(
        jnp.abs(self.nodes.velocity) &lt; 1e-12,
        jnp.zeros_like(self.nodes.velocity),
        self.nodes.velocity,
    )
    self.nodes.acceleration = jnp.where(
        jnp.abs(self.nodes.acceleration) &lt; 1e-12,
        jnp.zeros_like(self.nodes.acceleration),
        self.nodes.acceleration,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="diffmpm" href="index.html">diffmpm</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="diffmpm.element.Linear1D" href="#diffmpm.element.Linear1D">Linear1D</a></code></h4>
<ul class="">
<li><code><a title="diffmpm.element.Linear1D.compute_internal_force" href="#diffmpm.element.Linear1D.compute_internal_force">compute_internal_force</a></code></li>
<li><code><a title="diffmpm.element.Linear1D.compute_volume" href="#diffmpm.element.Linear1D.compute_volume">compute_volume</a></code></li>
<li><code><a title="diffmpm.element.Linear1D.id_to_node_ids" href="#diffmpm.element.Linear1D.id_to_node_ids">id_to_node_ids</a></code></li>
<li><code><a title="diffmpm.element.Linear1D.set_particle_element_ids" href="#diffmpm.element.Linear1D.set_particle_element_ids">set_particle_element_ids</a></code></li>
<li><code><a title="diffmpm.element.Linear1D.shapefn" href="#diffmpm.element.Linear1D.shapefn">shapefn</a></code></li>
<li><code><a title="diffmpm.element.Linear1D.shapefn_grad" href="#diffmpm.element.Linear1D.shapefn_grad">shapefn_grad</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="diffmpm.element.Quadrilateral4Node" href="#diffmpm.element.Quadrilateral4Node">Quadrilateral4Node</a></code></h4>
<ul class="">
<li><code><a title="diffmpm.element.Quadrilateral4Node.compute_internal_force" href="#diffmpm.element.Quadrilateral4Node.compute_internal_force">compute_internal_force</a></code></li>
<li><code><a title="diffmpm.element.Quadrilateral4Node.compute_volume" href="#diffmpm.element.Quadrilateral4Node.compute_volume">compute_volume</a></code></li>
<li><code><a title="diffmpm.element.Quadrilateral4Node.id_to_node_ids" href="#diffmpm.element.Quadrilateral4Node.id_to_node_ids">id_to_node_ids</a></code></li>
<li><code><a title="diffmpm.element.Quadrilateral4Node.set_particle_element_ids" href="#diffmpm.element.Quadrilateral4Node.set_particle_element_ids">set_particle_element_ids</a></code></li>
<li><code><a title="diffmpm.element.Quadrilateral4Node.shapefn" href="#diffmpm.element.Quadrilateral4Node.shapefn">shapefn</a></code></li>
<li><code><a title="diffmpm.element.Quadrilateral4Node.shapefn_grad" href="#diffmpm.element.Quadrilateral4Node.shapefn_grad">shapefn_grad</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="diffmpm.element._Element" href="#diffmpm.element._Element">_Element</a></code></h4>
<ul class="">
<li><code><a title="diffmpm.element._Element.apply_boundary_constraints" href="#diffmpm.element._Element.apply_boundary_constraints">apply_boundary_constraints</a></code></li>
<li><code><a title="diffmpm.element._Element.apply_concentrated_nodal_forces" href="#diffmpm.element._Element.apply_concentrated_nodal_forces">apply_concentrated_nodal_forces</a></code></li>
<li><code><a title="diffmpm.element._Element.apply_force_boundary_constraints" href="#diffmpm.element._Element.apply_force_boundary_constraints">apply_force_boundary_constraints</a></code></li>
<li><code><a title="diffmpm.element._Element.apply_particle_traction_forces" href="#diffmpm.element._Element.apply_particle_traction_forces">apply_particle_traction_forces</a></code></li>
<li><code><a title="diffmpm.element._Element.compute_body_force" href="#diffmpm.element._Element.compute_body_force">compute_body_force</a></code></li>
<li><code><a title="diffmpm.element._Element.compute_external_force" href="#diffmpm.element._Element.compute_external_force">compute_external_force</a></code></li>
<li><code><a title="diffmpm.element._Element.compute_nodal_mass" href="#diffmpm.element._Element.compute_nodal_mass">compute_nodal_mass</a></code></li>
<li><code><a title="diffmpm.element._Element.compute_nodal_momentum" href="#diffmpm.element._Element.compute_nodal_momentum">compute_nodal_momentum</a></code></li>
<li><code><a title="diffmpm.element._Element.compute_velocity" href="#diffmpm.element._Element.compute_velocity">compute_velocity</a></code></li>
<li><code><a title="diffmpm.element._Element.concentrated_nodal_forces" href="#diffmpm.element._Element.concentrated_nodal_forces">concentrated_nodal_forces</a></code></li>
<li><code><a title="diffmpm.element._Element.id_to_node_ids" href="#diffmpm.element._Element.id_to_node_ids">id_to_node_ids</a></code></li>
<li><code><a title="diffmpm.element._Element.id_to_node_loc" href="#diffmpm.element._Element.id_to_node_loc">id_to_node_loc</a></code></li>
<li><code><a title="diffmpm.element._Element.id_to_node_vel" href="#diffmpm.element._Element.id_to_node_vel">id_to_node_vel</a></code></li>
<li><code><a title="diffmpm.element._Element.nodes" href="#diffmpm.element._Element.nodes">nodes</a></code></li>
<li><code><a title="diffmpm.element._Element.set_particle_element_ids" href="#diffmpm.element._Element.set_particle_element_ids">set_particle_element_ids</a></code></li>
<li><code><a title="diffmpm.element._Element.shapefn" href="#diffmpm.element._Element.shapefn">shapefn</a></code></li>
<li><code><a title="diffmpm.element._Element.shapefn_grad" href="#diffmpm.element._Element.shapefn_grad">shapefn_grad</a></code></li>
<li><code><a title="diffmpm.element._Element.total_elements" href="#diffmpm.element._Element.total_elements">total_elements</a></code></li>
<li><code><a title="diffmpm.element._Element.tree_flatten" href="#diffmpm.element._Element.tree_flatten">tree_flatten</a></code></li>
<li><code><a title="diffmpm.element._Element.tree_unflatten" href="#diffmpm.element._Element.tree_unflatten">tree_unflatten</a></code></li>
<li><code><a title="diffmpm.element._Element.update_nodal_acceleration_velocity" href="#diffmpm.element._Element.update_nodal_acceleration_velocity">update_nodal_acceleration_velocity</a></code></li>
<li><code><a title="diffmpm.element._Element.volume" href="#diffmpm.element._Element.volume">volume</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>