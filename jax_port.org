#+title: Jax Port for MPM
#+property: header-args :session mpm :async yes :exports both :eval no-export

This document covers the process of porting the [[https://github.com/cb-geo/mpm/][CB-GEO MPM]] functionalities to a JAX based version. The initial idea is to implement basic classes for different elements of the MPM such that the classes can be then inherited/extended to provide support for 1D/2D/3D MPM. The first steps are just to implement the 1D case with extensibility in mind.

* Classes
** Nodes
Nodes are one of the two most basic structures used in MPM. Nodes have their mass, velocity, momentum, internal forces, external forces and damping forces that are then used for particle updates. Instead of having every node as a class instance and maintaining a container of Node objects (/array of structs/), we will try to make the ~Node~ class a generic container class that takes in the number of nodes required and maintain its own arrays (/struct of arrays/).

#+begin_src jupyter-python :tangle diffmpm/node.py
import jax.numpy as jnp


class Nodes:
    """
    Nodes container class.

    Keeps track of all values required for nodal points.

    Attributes
    ----------
    nnodes : int
        Number of nodes stored.
    position : array_like
        Position of all the nodes.
    velocity : array_like
        Velocity of all the nodes.
    mass : array_like
        Mass of all the nodes.
    momentum : array_like
        Momentum of all the nodes.
    f_int : array_like
        Internal forces on all the nodes.
    f_ext : array_like
        External forces present on all the nodes.
    f_damp : array_like
        Damping forces on the nodes.
    """
    def __init__(self, n):
        """
        Parameters
        ----------
        n : int
            Number of nodes in the mesh.
        """
        self.nnodes = n
        self.position = jnp.zeros(n)
        self.velocity = jnp.zeros(n)
        self.mass = jnp.zeros(n)
        self.momentum = jnp.zeros(n)
        self.f_int = jnp.zeros(n)
        self.f_ext = jnp.zeros(n)
        self.f_damp = jnp.zeros(n)
        return

    def _reset_values(self):
        self.position.fill(0)
        self.velocity.fill(0)
        self.mass.fill(0)
        self.momentum.fill(0)
        self.f_int.fill(0)
        self.f_ext.fill(0)
        self.f_damp.fill(0)
#+end_src

The current implementation of nodes sets 1D arrays for all the variables. When extending to 2D, a decision will have to be made on if we want to store the nodes in a 2D array or in a 1D array with implicit indexing.
** Shape function
The shape function is used to map the nodes to material points (and vice-versa) with independent variable of the location of each material point at time t. Depending on the dimension of the problem, the shape functions take different forms. For example, the shape function in 1D is given as

\[
N(x) = \left[\frac{1-x}{2}, \frac{1+x}{2}\right]
\]

In code, these shape functions are implemented such that they return a vector. There are also gradient functions implemented for them.
#+begin_src jupyter-python :tangle diffmpm/shapefn.py
import jax.numpy as jnp
from jax import jacobian, vmap, lax


class ShapeFn:
    """
    Define the shape function of an element.

    Based on the dimension, the shape function returns the required
    mapped nodal values.

    Attributes
    ----------
    dim : int
        Dimension of the shape function.
    """

    def __init__(self, dim=1):
        """
        Construct Shape functions for the given dimension.

        Arguments
        ---------
        dim : int
            Dimension of the shape function to be used.
        """
        self.dim = dim
        return

    def shapefn(self, x):
        """
        Return value of the shape function.

        Based on the dimension provided to the constructor, this returns
        the value of the shape function in the natural coordinates.

        Arguments
        ---------
        x : float, array_like
            Locations in natural coordinates to evaluate the function at.

        Returns
        -------
        array_like
            Evaluated shape function values. The shape of the returned
        array will depend on the input shape. For example, in the linear
        case, if the input is a scalar, the returned array will be of
        the shape (2,) but if the input is a vector then the output will
        be of the shape (len(x), 2).
        """
        if self.dim == 1:
            result = jnp.array([0.5 * (1 - x), 0.5 * (1 + x)])
        return result

    def _shapefn_natural_grad(self, x):
        """
        Calculate the gradient of shape function.

        This calculation is done in the natural coordinates.

        Arguments
        ---------
        x : float, array_like
            Locations in natural coordinates to evaluate the function at.

        Returns
        -------
        array_like
            Evaluated gradient values of the shape function. The shape of
        the returned array will depend on the input shape. For example,
        in the linear case, if the input is a scalar, the returned array
        will be of the shape (2,) but if the input is a vector then the
        output will be of the shape (len(x), 2).
        """
        if jnp.isscalar(x):
            result = jacobian(self.shapefn)(x)
        else:
            result = vmap(jacobian(self.shapefn))(x)

        # TODO: The following code tries to evaluate vmap even if
        # the predicate condition is true, not sure why.
        # result = lax.cond(
        #     jnp.isscalar(x),
        #     jacobian(self.shapefn),
        #     vmap(jacobian(self.shapefn)),
        #     x
        # )
        return result

    def shapefn_grad(self, x, coords):
        """
        Gradient of shape function in physical coordinates.

        Arguments
        ---------
        x : float, array_like
            Locations to evaluate in natural coordinates.
        coords : array_like
            Nodal coordinates to transform by.

        Returns
        -------
        array_like
            Gradient of the shape function in physical coordinates at `x`
        """
        length = abs(coords[1] - coords[0])
        result = self._shapefn_natural_grad(x) * 2 / length
        return result
#+end_src
** Particles
