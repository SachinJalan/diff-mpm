#+title: Jax Port for MPM
#+property: header-args :session mpm :async yes :exports both :eval no-export

This document covers the process of porting the [[https://github.com/cb-geo/mpm/][CB-GEO MPM]] functionalities to a JAX based version. The initial idea is to implement basic classes for different elements of the MPM such that the classes can be then inherited/extended to provide support for 1D/2D/3D MPM. The first steps are just to implement the 1D case with extensibility in mind.

* Classes
** Nodes
Nodes are one of the two most basic structures used in MPM. Nodes have their mass, velocity, momentum, internal forces, external forces and damping forces that are then used for particle updates. Instead of having every node as a class instance and maintaining a container of Node objects (/array of structs/), we will try to make the ~Node~ class a generic container class that takes in the number of nodes required and maintain its own arrays (/struct of arrays/).

#+begin_src jupyter-python :tangle diffmpm/node.py
import jax.numpy as jnp
from jax.tree_util import register_pytree_node_class


@register_pytree_node_class
class Nodes:
    """
    Nodes container class.

    Keeps track of all values required for nodal points.

    Attributes
    ----------
    nnodes : int
        Number of nodes stored.
    position : array_like
        Position of all the nodes.
    velocity : array_like
        Velocity of all the nodes.
    mass : array_like
        Mass of all the nodes.
    momentum : array_like
        Momentum of all the nodes.
    f_int : array_like
        Internal forces on all the nodes.
    f_ext : array_like
        External forces present on all the nodes.
    f_damp : array_like
        Damping forces on the nodes.
    """

    def __init__(self, nnodes, position, velocity, mass, momentum, f_int, f_ext, f_damp):
        """
        Parameters
        ----------
        nnodes : int
            Number of nodes stored.
        position : array_like
            Position of all the nodes.
        velocity : array_like
            Velocity of all the nodes.
        mass : array_like
            Mass of all the nodes.
        momentum : array_like
            Momentum of all the nodes.
        f_int : array_like
            Internal forces on all the nodes.
        f_ext : array_like
            External forces present on all the nodes.
        f_damp : array_like
            Damping forces on the nodes.
        """
        self.nnodes = nnodes
        self.position = position
        self.velocity = velocity
        self.mass = mass
        self.momentum = momentum
        self.f_int = f_int
        self.f_ext = f_ext
        self.f_damp = f_damp
        return

    def tree_flatten(self):
        children = (
            self.position,
            self.velocity,
            self.mass,
            self.momentum,
            self.f_int,
            self.f_ext,
            self.f_damp,
        )
        aux_data = (self.nnodes,)
        return (children, aux_data)

    @classmethod
    def tree_unflatten(cls, aux_data, children):
        return cls(*aux_data, *children)

    def reset_values(self):
        self.velocity = self.velocity.at[:].set(0)
        self.mass = self.mass.at[:].set(0)
        self.momentum = self.momentum.at[:].set(0)
        self.f_int = self.f_int.at[:].set(0)
        self.f_ext = self.f_ext.at[:].set(0)
        self.f_damp = self.f_damp.at[:].set(0)

    def __len__(self):
        return self.nnodes

    def __repr__(self):
        return f"Nodes(n={self.nnodes})"

    def get_total_force(self):
        return self.f_int + self.f_ext + self.f_damp
#+end_src

The current implementation of nodes sets 1D arrays for all the variables. When extending to 2D, a decision will have to be made on if we want to store the nodes in a 2D array or in a 1D array with implicit indexing.
** Shape function
The shape function is used to map the nodes to material points (and vice-versa) with independent variable of the location of each material point at time t. Depending on the dimension of the problem, the shape functions take different forms. For example, the shape function in 1D is given as

\[
N(x) = \left[\frac{1-x}{2}, \frac{1+x}{2}\right]
\]

In code, these shape functions are implemented such that they return a vector. There are also gradient functions implemented for them.
#+begin_src jupyter-python :tangle diffmpm/shapefn.py
import jax.numpy as jnp
from jax import jacobian, vmap, lax
from jax.tree_util import register_pytree_node_class


@register_pytree_node_class
class ShapeFn:
    """
    Define the shape function of an element.

    Based on the dimension, the shape function returns the required
    mapped nodal values.

    Attributes
    ----------
    dim : int
        Dimension of the shape function.
    """

    def __init__(self, dim=1):
        """
        Construct Shape functions for the given dimension.

        Arguments
        ---------
        dim : int
            Dimension of the shape function to be used.
        """
        self.dim = dim
        return

    def tree_flatten(self):
        return ((self.dim,), None)

    @classmethod
    def tree_unflatten(cls, aux_data, children):
        del aux_data
        return cls(*children)

    def __repr__(self):
        return f"ShapeFn(dim={self.dim})"
    
    def shapefn(self, xi):
        """
        Return value of the shape function.

        Based on the dimension provided to the constructor, this returns
        the value of the shape function in the natural coordinates.

        Arguments
        ---------
        xi : float, array_like
            Locations in natural coordinates to evaluate the function at.

        Returns
        -------
        array_like
            Evaluated shape function values. The shape of the returned
        array will depend on the input shape. For example, in the linear
        case, if the input is a scalar, the returned array will be of
        the shape (2,) but if the input is a vector then the output will
        be of the shape (len(x), 2).
        """
        if self.dim == 1:
            result = jnp.array([0.5 * (1 - xi), 0.5 * (1 + xi)]).T
        return result

    def _shapefn_natural_grad(self, xi):
        """
        Calculate the gradient of shape function.

        This calculation is done in the natural coordinates.

        Arguments
        ---------
        x : float, array_like
            Locations in natural coordinates to evaluate the function at.

        Returns
        -------
        array_like
            Evaluated gradient values of the shape function. The shape of
        the returned array will depend on the input shape. For example,
        in the linear case, if the input is a scalar, the returned array
        will be of the shape (2,) but if the input is a vector then the
        output will be of the shape (len(x), 2).
        """
        if jnp.isscalar(xi):
            result = jacobian(self.shapefn)(xi)
        else:
            result = vmap(jacobian(self.shapefn))(xi.reshape(-1, 1)).squeeze()

        # TODO: The following code tries to evaluate vmap even if
        # the predicate condition is true, not sure why.
        # result = lax.cond(
        #     jnp.isscalar(x),
        #     jacobian(self.shapefn),
        #     vmap(jacobian(self.shapefn)),
        #     xi
        # )
        return result

    def shapefn_grad(self, x, coords):
        """
        Gradient of shape function in physical coordinates.

        Arguments
        ---------
        x : float, array_like
            Locations to evaluate in natural coordinates.
        coords : array_like
            Nodal coordinates to transform by.

        Returns
        -------
        array_like
            Gradient of the shape function in physical coordinates at `x`
        """
        if self.dim == 1:
            length = abs(coords[1] - coords[0])
            result = self._shapefn_natural_grad(x) * 2 / length
        return result
#+end_src
** Material
A class containing all material properties.
#+begin_src jupyter-python :tangle diffmpm/material.py
from jax.tree_util import register_pytree_node_class


@register_pytree_node_class
class Material:
    """
    Base material class.
    """

    def __init__(self, E, density):
        """
        Initialize material properties.

        Arguments
        ---------
        E : float
            Young's modulus of the material.
        density : float
            Density of the material.
        """
        self.E = E
        self.density = density

    def tree_flatten(self):
        return (tuple(), (self.E, self.density))

    @classmethod
    def tree_unflatten(cls, aux_data, children):
        del children
        return cls(*aux_data)

    def __repr__(self):
        return f"Material(E={self.E}, density={self.density})"
#+end_src
** Particles
~Particles~ is a container class for the material particle points on the mesh. It keeps track of different properties of the particles like mass, velocity, volumne, density, stress, strain etc.
#+begin_src jupyter-python :tangle diffmpm/particle.py
import jax.numpy as jnp
from jax.tree_util import register_pytree_node_class


@register_pytree_node_class
class Particles:
    """
    Container class for particles on a mesh.
    """

    def __init__(
        self,
        mass,
        x,
        xi,
        density,
        element_ids,
        velocity,
        volume,
        stress,
        strain,
        dstrain,
        f_ext,
        ppe=1,
        nelements=1,
        nparticles=1,
        material=None,
        ptype="uniform",
    ):
        """
        Construct a container for particles.

        Arguments
        ---------
        mass : float, array_like
            Mass of each particle. Can be a float or an array for mass
        of each particle.
        x : array_like
            Position of particles in physical coordinates.
        xi : array_like
            Position of particles in natural coordinates.
        material : diffmpm.material.Material
            Material type of the mesh the particles are a part of.
        density : float, array_like
            Density of each particle. Can be a float or an array for
        density of each particle.
        ppe : int
            Number of particles per element.
        nelements : int
            Number of elements that contain the particles.
        element_ids : array_like
            Ids of the elements that each particle is a part of.
        """
        self.material = material
        self.ppe = ppe
        self.nparticles = ppe * nelements
        self.x = x
        self.xi = xi
        self.element_ids = element_ids
        self.mass = (
            mass if not jnp.isscalar(mass) else jnp.ones(self.nparticles) * mass
        )
        self.density = (
            density
            if not jnp.isscalar(density)
            else jnp.ones(self.nparticles) * density
        )

        self.velocity = velocity
        self.volume = volume
        self.stress = stress
        self.strain = strain
        self.dstrain = dstrain
        self.f_ext = f_ext

        return

    def __len__(self):
        return self.nparticles

    def __repr__(self):
        return f"Particles(nparticles={self.nparticles})"

    def tree_flatten(self):
        children = (
            self.mass,
            self.x,
            self.xi,
            self.density,
            self.element_ids,
            self.velocity,
            self.volume,
            self.stress,
            self.strain,
            self.dstrain,
            self.f_ext,
        )
        aux_data = {
            "material": self.material,
            "ppe": self.ppe,
            "nelements": self.nparticles // self.ppe,
            "nparticles": self.nparticles,
        }
        return (children, aux_data)

    @classmethod
    def tree_unflatten(cls, aux_data, children):
        return cls(
            ,*children[:5],
            ,*children[5:],
            ,**aux_data,
        )
#+end_src
** Mesh
A mesh is a container made up of multiple Elements. Each /Element/ is the single cell that combine with more /elements/ to generate the entire mesh. Furthermore, each element contains its own set of nodes and material particle points. Since these particles require the information of which "element" they belong to, one implementation can be done such that the Mesh class (and in turn the elements) owns the particles and elements. This allows easy information transfer about the elements to the particles.

Of importance is the ~_update_particle_element_ids()~ method. This method took a little while to be implemented in such a way that it works fine with JIT compatible functions. This limited the usage of control flow statements and other functions. Particularly, functions whose return value is conditioned on the input value don't work very great with JIT compatibility. To work around this, the local JIT function ~f()~ first performs the computationally heavy task of finding the indices that match the conditions. After that, ~jnp.where()~ is used to generate the final array of element indices. ~jnp.where()~ was not used in the function ~f()~ because ~jnp.where(cond, x, y)~ with 3 arguments is JIT compatible but ~jnp.where(cond)~ is not, as the output size for that function is input dependent.
#+begin_src jupyter-python :tangle diffmpm/mesh.py
import jax.numpy as jnp
from jax import vmap, lax, jit
from tqdm import tqdm
from diffmpm.node import Nodes
from diffmpm.particle import Particles
from diffmpm.shapefn import ShapeFn
from jax.tree_util import register_pytree_node_class
from jax_tqdm import loop_tqdm
from functools import partial

from jax import debug


@register_pytree_node_class
class Mesh1D:
    """
    1D Mesh class with nodes, elements, and particles.
    """

    def __init__(
        self,
        nelements,
        material,
        domain_size,
        boundary_nodes,
        ,*,
        ppe=1,
        particle_distribution="uniform",
        elements=None,
        nodes=None,
        particles=None,
        shapefn=None,
        dim=1,
    ):
        """
        Construct a 1D Mesh.

        Arguments
        ---------
        nelements : int
            Number of elements in the mesh.
        material : diffmpm.material.Material
            Material to meshed.
        domain_size : float
            The size of the domain in consideration.
        boundary_nodes : array_like
            Node ids of boundary nodes of the mesh. Needs to be a JAX
        array.
        ppe : int
            Number of particles per element in Mesh.
        """
        self.dim = dim
        self.material = material
        self.shapefn = (
            ShapeFn(self.dim)
            if (
                shapefn is None
                or type(shapefn) is object
                or isinstance(shapefn, Mesh1D)
            )
            else shapefn
        )
        self.domain_size = domain_size
        self.nelements = nelements
        self.element_length = domain_size / nelements
        self.elements = jnp.arange(nelements) if elements is None else elements
        nnodes = nelements + 1
        self.nodes = (
            Nodes(
                nnodes,
                jnp.arange(nelements + 1) * self.element_length,
                jnp.zeros(nnodes),
                jnp.zeros(nnodes),
                jnp.zeros(nnodes),
                jnp.zeros(nnodes),
                jnp.zeros(nnodes),
                jnp.zeros(nnodes),
            )
            if (
                nodes is None
                or type(nodes) is object
                or isinstance(nodes, Mesh1D)
            )
            else nodes
        )
        self.boundary_nodes = boundary_nodes
        self.ppe = ppe
        self.particles = (
            self._init_particles(particle_distribution)
            if (
                particles is None
                or type(particles) is object
                or isinstance(particles, Mesh1D)
            )
            else particles
        )
        return

    def tree_flatten(self):
        "Flatten Pytree for JAX JIT compatibility."
        children = (self.nodes, self.particles)
        aux_data = (
            (
                self.nelements,
                self.material,
                self.domain_size,
                self.boundary_nodes,
            ),
            {
                "dim": self.dim,
                "shapefn": self.shapefn,
                "elements": self.elements,
                "ppe": self.ppe,
            },
        )
        return (children, aux_data)

    @classmethod
    def tree_unflatten(cls, aux_data, children):
        "Unflatten Pytree for JAX JIT compatibility."
        return cls(
            ,*aux_data[0],
            nodes=children[0],
            particles=children[1],
            ,**aux_data[1],
        )

    def _init_particles(self, distribution="uniform"):
        temp_px = jnp.linspace(0, self.element_length, self.ppe + 1)
        if distribution == "uniform":
            pmass = self.element_length * self.material.density / self.ppe
            element_particle_x = (temp_px[1:] + temp_px[:-1]) / 2
            particles_x = jnp.hstack(
                [(x + element_particle_x) for x in self.nodes.position[:-1]]
            )
            particles_xi = jnp.tile(element_particle_x, self.nelements)
            particle_element_ids = jnp.repeat(
                jnp.arange(self.nelements), self.ppe
            )
            nparticles = (self.ppe * self.nelements,)
            particles = Particles(
                pmass,
                particles_x,
                particles_xi,
                self.material.density,
                particle_element_ids,
                jnp.zeros(nparticles),
                jnp.zeros(nparticles),
                jnp.zeros(nparticles),
                jnp.zeros(nparticles),
                jnp.zeros(nparticles),
                jnp.zeros(nparticles),
                ppe=self.ppe,
                nelements=self.nelements,
                nparticles=nparticles,
                material=self.material,
            )
            return particles
        else:
            raise ValueError(
                f"{type} type particle initialization not "
                f"yet supported. Please use 'uniform'."
            )

    def _get_element_node_ids(self, element_idx):
        """
        Given an element at index `element_idx`, return the
        mapping node coordinates for that element.
        """
        return jnp.asarray([element_idx, element_idx + 1])

    def _get_element_node_pos(self, element_idx):
        """
        Given an element at index `element_idx`, return the
        mapping node coordinates for that element.
        """
        return self.nodes.position[jnp.asarray([element_idx, element_idx + 1])]

    def _get_element_node_vel(self, element_idx):
        """
        Given an element at index `element_idx`, return the
        mapping node coordinates for that element.
        """
        return self.nodes.velocity[jnp.asarray([element_idx, element_idx + 1])]

    def set_particle_velocity(self, vel):
        """
        Set the velocities of all particles.

        Arguments
        ---------
        vel : array_like
            Velocity for each particle in the mesh.
        """
        self.particles.velocity = vel

    def _update_particle_element_ids(self):
        """
        Find the element that the particles belong to.

        If the particle doesn't lie between the boundaries of any
        element, it sets the element index to -1.
        """

        @jit
        def f(x):
            idl = (
                len(self.nodes.position)
                - 1
                - jnp.asarray(self.nodes.position[::-1] <= x).nonzero(
                    size=1, fill_value=-1
                )[0][-1]
            )
            idg = (
                jnp.asarray(self.nodes.position > x).nonzero(
                    size=1, fill_value=-1
                )[0][0]
                - 1
            )
            return (idl, idg)

        ids = vmap(f)(self.particles.x)
        self.particles.element_ids = jnp.where(
            ids[0] == ids[1], ids[0], jnp.ones_like(ids[0]) * -1
        )

    def _update_particle_natural_coords(self):
        r"""
        Update natural coordinates for the particles.

        Whenever the particles' physical coordinates change, their
        natural coordinates need to be updated. This function updates
        the natural coordinates of the particles based on the element
        a particle is a part of. The update formula is

        :math:`xi = (x - x_{n_0}) 2 / l - 1`

        If a particle is not in any element (element_id = -1), its
        natural coordinate is set to 0.
        """
        t = self.nodes.position[self.particles.element_ids]
        t = jnp.where(
            self.particles.element_ids == -1,
            self.particles.x - self.element_length / 2,
            t,
        )
        xi_coords = (self.particles.x - t) * 2 / self.element_length - 1
        self.particles.xi = xi_coords

    def _update_particle_strain(self, dt):
        """
        Calculate the strain values for particles.

        This calculation is done by mapping the nodal velocities
        with the gradient of the interpolation shape function.

        Arguments
        ---------
        dt : float
            Time step.
        """

        nodal_coords = vmap(self._get_element_node_pos)(
            self.particles.element_ids
        )
        # particles_dndx will be of shape (nparticles, element.nnodes)
        particles_dndx = vmap(self.shapefn.shapefn_grad)(
            self.particles.xi, nodal_coords
        )
        nodal_vel = vmap(self._get_element_node_vel)(self.particles.element_ids)

        # strain rate is the row-wise sum of the matrix particles_dndx x nodal_vel
        strain_rate = jnp.sum(particles_dndx * nodal_vel, axis=1)

        self.particles.dstrain = strain_rate * dt
        self.particles.strain += self.particles.dstrain

    def _update_particle_stress(self):
        self.particles.stress += self.particles.dstrain * self.material.E

    def _update_nodes_acc_vel(self, dt):
        """
        Compute acceleration based velocity.

        The velocity at nodes is calculated based on the acceleration
        achieved by the force on the nodes and added to the current
        velocity. For velocity update using momentum see
        `diffmpm.Mesh._update_nodes_mom_vel()`

        Arguments
        ---------
        dt : float
            Time step.
        """
        total_force = self.nodes.get_total_force()

        def f(f, m):
            nodal_acceleration = lax.cond(
                m == 0,
                lambda cf, cm: 0.0,
                lambda cf, cm: jnp.divide(cf, cm),
                f,
                m,
            )
            return nodal_acceleration

        nodal_acceleration = vmap(f)(total_force, self.nodes.mass)
        self.nodes.velocity += nodal_acceleration * dt

    def _update_nodes_mom_vel(self):
        """
        Compute momentum based velocity.

        The velocity of the nodes is calculated based on the current
        momentum at the nodes. This function _sets_ the value of the
        velocities for each node. For acceleration based update see
        `diffmpm.Mesh._update_nodes_acc_vel()`
        """

        def f(p, m):
            velocity = lax.cond(
                m == 0,
                lambda cp, cm: jnp.zeros_like(cp),
                lambda cp, cm: jnp.divide(cp, cm),
                p,
                m,
            )
            return velocity

        nodal_velocity = vmap(f)(self.nodes.momentum, self.nodes.mass)
        self.nodes.velocity = nodal_velocity

    def _update_nodes_bc_mom_vel(self):
        """
        Set momentum and velocity of boundary nodes.

        Based on the boundary conditions of the mesh, the nodes at the
        boundary points are set to 0 momentum and velocity.
        """
        self.nodes.momentum = self.nodes.momentum.at[self.boundary_nodes].set(0)
        self.nodes.velocity = self.nodes.velocity.at[self.boundary_nodes].set(0)

    def _update_nodes_bc_force(self):
        """
        Set forces of boundary nodes.

        Based on the boundary conditions of the mesh, the forces on the
        nodes at the boundary points are set to 0.
        """
        self.nodes.f_int = self.nodes.f_int.at[self.boundary_nodes].set(0)
        self.nodes.f_ext = self.nodes.f_ext.at[self.boundary_nodes].set(0)
        self.nodes.f_damp = self.nodes.f_damp.at[self.boundary_nodes].set(0)

    def _update_node_momentum_force(self, dt):
        """
        Update the momentum at nodes based on force

        :math:`p += total_force * dt`

        Arguments
        ---------
        dt : float
            Time step.
        """
        self.nodes.momentum += (
            self.nodes.f_int + self.nodes.f_ext + self.nodes.f_damp
        ) * dt

    def _update_node_momentum_par_vel(self):
        r"""
        Update the nodal momentum based on particle velocity.

        The nodal momentum is updated as a sum of particle momentum for
        all particles mapped to the node.

        :math:`(mv)_i = \sum_p N_i(x_p) m_p v_p`
        """
        self.nodes.momentum = self.nodes.momentum.at[:].set(0)

        def step(pid, args):
            momentum, mass, velocity, mapped_pos, el_nodes = args
            momentum = momentum.at[el_nodes[pid]].add(
                mass[pid] * velocity[pid] * mapped_pos[pid]
            )
            return momentum, mass, velocity, mapped_pos, el_nodes

        mapped_positions = self.shapefn.shapefn(self.particles.xi)
        mapped_nodes = vmap(self._get_element_node_ids)(
            self.particles.element_ids
        )
        args = (
            self.nodes.momentum,
            self.particles.mass,
            self.particles.velocity,
            mapped_positions,
            mapped_nodes,
        )
        self.nodes.momentum, _, _, _, _ = lax.fori_loop(
            0, len(self.particles), step, args
        )

    def _transfer_node_force_vel_par(self, dt):
        """
        Transfer nodal velocity to particles.

        The velocity is calculated based on the total force at nodes.

        Arguments
        ---------
        dt : float
            Timestep.
        """
        mapped_positions = self.shapefn.shapefn(self.particles.xi)
        mapped_ids = vmap(self._get_element_node_ids)(
            self.particles.element_ids
        )
        total_force = self.nodes.get_total_force()
        self.particles.velocity = self.particles.velocity.at[:].add(
            jnp.sum(
                mapped_positions
                ,* jnp.divide(
                    total_force[mapped_ids], self.nodes.mass[mapped_ids]
                )
                ,* dt,
                axis=1,
            )
        )

    def _update_par_pos_node_mom(self, dt):
        """
        Update particle position based on nodal momentum.

        Arguments
        ---------
        dt : float
            Time step.
        """
        mapped_positions = self.shapefn.shapefn(self.particles.xi)
        mapped_ids = vmap(self._get_element_node_ids)(
            self.particles.element_ids
        )
        self.particles.x = self.particles.x.at[:].add(
            jnp.sum(
                mapped_positions
                ,* jnp.divide(
                    self.nodes.momentum[mapped_ids], self.nodes.mass[mapped_ids]
                )
                ,* dt,
                axis=1,
            )
        )

    def _update_par_pos_vel_node_vel(self, dt):
        """
        Update particle position and velocity based on nodal velocity.

        Arguments
        ---------
        dt : float
            Timestep.
        """
        mapped_positions = self.shapefn.shapefn(self.particles.xi)
        mapped_vel = vmap(self._get_element_node_vel)(
            self.particles.element_ids
        )
        self.particles.velocity = self.particles.velocity.at[:].set(
            jnp.sum(
                mapped_positions * mapped_vel,
                axis=1,
            )
        )
        self.particles.x = self.particles.x.at[:].add(
            self.particles.velocity * dt
        )

    def _update_par_vol_density(self):
        """
        Update the particle volume and density based on dstrain.
        """
        self.particles.volume = self.particles.volume.at[:].multiply(
            1 + self.particles.dstrain
        )
        self.particles.density = self.particles.density.at[:].divide(
            1 + self.particles.dstrain
        )

    def _update_node_mass_par_mass(self):
        r"""
        Update the nodal mass based on particle mass.

        The nodal mass is updated as a sum of particle mass for
        all particles mapped to the node.

        :math:`(m)_i = \sum_p N_i(x_p) m_p`
        """

        def step(pid, args):
            pmass, mass, mapped_pos, el_nodes = args
            mass = mass.at[el_nodes[pid]].add(pmass[pid] * mapped_pos[pid])
            return pmass, mass, mapped_pos, el_nodes

        mapped_positions = self.shapefn.shapefn(self.particles.xi)
        mapped_nodes = vmap(self._get_element_node_ids)(
            self.particles.element_ids
        )
        args = (
            self.particles.mass,
            self.nodes.mass,
            mapped_positions,
            mapped_nodes,
        )
        _, self.nodes.mass, _, _ = lax.fori_loop(
            0, len(self.particles), step, args
        )

    def _update_node_fext_par_mass(self, gravity):
        r"""
        Update the nodal external force based on particle mass.

        The nodal force is updated as a sum of particle weight for
        all particles mapped to the node.

        :math:`(f_{ext})_i = \sum_p N_i(x_p) m_p g`
        """

        def step(pid, args):
            f_ext, pmass, mapped_pos, el_nodes, gravity = args
            f_ext = f_ext.at[el_nodes[pid]].add(
                pmass[pid] * mapped_pos[pid] * gravity
            )
            return f_ext, pmass, mapped_pos, el_nodes, gravity

        mapped_positions = self.shapefn.shapefn(self.particles.xi)
        mapped_nodes = vmap(self._get_element_node_ids)(
            self.particles.element_ids
        )
        args = (
            self.nodes.f_ext,
            self.particles.mass,
            mapped_positions,
            mapped_nodes,
            gravity,
        )
        self.nodes.f_ext, _, _, _, _ = lax.fori_loop(
            0, len(self.particles), step, args
        )

    def _update_node_fint_par_mass(self):
        r"""
        Update the nodal internal force based on particle mass.

        The nodal force is updated as a sum of internal forces for
        all particles mapped to the node.

        :math:`(mv)_i = \sum_p N_i(x_p) * stress * m_p / density_p`
        """

        def step(pid, args):
            (
                f_int,
                pmass,
                mapped_grads,
                el_nodes,
                pstress,
                pdensity,
            ) = args
            f_int = f_int.at[el_nodes[pid]].add(
                -pmass[pid] * mapped_grads[pid] * pstress[pid] / pdensity[pid]
            )
            return (
                f_int,
                pmass,
                mapped_grads,
                el_nodes,
                pstress,
                pdensity,
            )

        mapped_nodes = vmap(self._get_element_node_ids)(
            self.particles.element_ids
        )
        mapped_grads = vmap(self.shapefn.shapefn_grad)(
            self.particles.x, mapped_nodes
        )
        args = (
            self.nodes.f_int,
            self.particles.mass,
            mapped_grads,
            mapped_nodes,
            self.particles.stress,
            self.particles.density,
        )
        self.nodes.f_int, _, _, _, _, _ = lax.fori_loop(
            0, len(self.particles), step, args
        )

    def _update_node_fext_par_fext(self):
        r"""
        Update the nodal external force based on particle f_ext.

        The nodal force is updated as a sum of particle external
        force for all particles mapped to the node.

        :math:`(mv)_i = \sum_p N_i(x_p) fext`
        """

        def step(pid, args):
            f_ext, pf_ext, mapped_pos, el_nodes = args
            f_ext = f_ext.at[el_nodes[pid]].add(mapped_pos[pid] * pf_ext[pid])
            return f_ext, pf_ext, mapped_pos, el_nodes

        mapped_positions = self.shapefn.shapefn(self.particles.xi)
        mapped_nodes = vmap(self._get_element_node_ids)(
            self.particles.element_ids
        )
        args = (
            self.nodes.f_ext,
            self.particles.f_ext,
            mapped_positions,
            mapped_nodes,
        )
        self.nodes.f_ext, _, _, _ = lax.fori_loop(
            0, len(self.particles), step, args
        )

    def solve(self, nsteps=100, mpm_scheme="USF", **kwargs):
        """
        Solve the mesh using explicit scheme (for now).
        """
        # TODO: Add flow control and argument checking
        result = {
            "position": [],
            "velocity": [],
        }
        for _ in tqdm(range(nsteps)):
            self._update_particle_natural_coords()
            self._update_particle_element_ids()
            self._update_node_momentum_par_vel()
            self._update_node_mass_par_mass()
            self._update_nodes_bc_mom_vel()
            if mpm_scheme == "USF":
                self._update_nodes_mom_vel()
                self._update_particle_strain(kwargs["dt"])
                # print(f"P.strain: {self.particles.strain}")
                self._update_par_vol_density()
                self._update_particle_stress()

            self._update_node_fint_par_mass()
            self._update_node_fext_par_fext()
            self._update_nodes_bc_force()
            self._update_node_momentum_force(kwargs["dt"])
            self._transfer_node_force_vel_par(kwargs["dt"])
            self._update_par_pos_node_mom(kwargs["dt"])
            if mpm_scheme == "MUSL":
                self._update_node_momentum_par_vel()
                self._update_nodes_bc_mom_vel()

            if mpm_scheme in {"MUSL", "USL"}:
                self._update_nodes_mom_vel()
                self._update_particle_strain(kwargs["dt"])
                self._update_par_vol_density()
                self._update_particle_stress()
            self.nodes.reset_values()
            result["position"].append(self.particles.x)
            result["velocity"].append(self.particles.velocity)
        result = {k: jnp.asarray(v) for k, v in result.items()}
        return result

    def solve_jit(self, nsteps=100, mpm_scheme=0, **kwargs):
        """
        Solve the mesh using explicit scheme (for now).

        mpm_scheme:
        {
            "USF": 0,
            "USL": 1,
            "MUSL": 2
        }
        """
        # TODO: Add flow control and argument checking
        result = {
            "position": jnp.zeros((nsteps, self.particles.nparticles)),
            "velocity": jnp.zeros((nsteps, self.particles.nparticles)),
        }
        mpm_scheme_dict = {"USF": 0, "USL": 1, "MUSL": 2}
        mpm_scheme = mpm_scheme_dict[mpm_scheme]

        @loop_tqdm(nsteps)
        def step(i, data):
            self, mpm_scheme, dt, result = data
            self._update_particle_natural_coords()
            self._update_particle_element_ids()
            self._update_node_momentum_par_vel()
            self._update_node_mass_par_mass()
            self._update_nodes_bc_mom_vel()

            # debug.breakpoint()
            # if mpm_scheme == 0:
            def f(data):
                # debug.breakpoint()
                s, dt = data
                s._update_nodes_mom_vel()
                s._update_particle_strain(dt)
                s._update_par_vol_density()
                s._update_particle_stress()
                return s

            # TODO: Confirm that it is fine doing this since
            # it sets a value to self.
            self = lax.cond(
                mpm_scheme == 0, f, lambda data: data[0], (self, dt)
            )

            self._update_node_fint_par_mass()
            self._update_node_fext_par_fext()
            self._update_nodes_bc_force()
            self._update_node_momentum_force(dt)
            self._transfer_node_force_vel_par(dt)
            self._update_par_pos_node_mom(dt)

            def f(s):
                s._update_node_momentum_par_vel()
                s._update_nodes_bc_mom_vel()
                return s

            self = lax.cond(mpm_scheme == 2, f, lambda s: s, self)

            def f(data):
                s, dt = data
                s._update_nodes_mom_vel()
                s._update_particle_strain(dt)
                s._update_par_vol_density()
                s._update_particle_stress()
                return s

            self = lax.cond(
                mpm_scheme == 1, f, lambda data: data[0], (self, dt)
            )
            self = lax.cond(
                mpm_scheme == 2, f, lambda data: data[0], (self, dt)
            )
            self.nodes.reset_values()
            result["position"] = (
                result["position"].at[i, :].set(self.particles.x)
            )
            result["velocity"] = (
                result["velocity"].at[i, :].set(self.particles.velocity)
            )
            return (self, mpm_scheme, dt, result)

        _, _, _, result = lax.fori_loop(
            0, nsteps, step, (self, mpm_scheme, kwargs["dt"], result)
        )
        result = {k: jnp.asarray(v) for k, v in result.items()}
        return result
#+end_src

* 1D vibration of a single material point
Consider the vibration of a single material point in an element. Initially the
point lies at \(x_p = L/2\) and has an initial velocity \(v_0\). In this case,
the exact solution for the velocity is given by \(v(t) = v_0 \cos(\omega t),
\omega = \frac{1}{L}\sqrt{E/\rho}\) and the position is given by
\(x(t) = x_0\exp{\left[ \frac{v_0}{L\omega}\sin(\omega t)\right]}\).
The analytical solution for this case then is:

#+begin_src jupyter-python
import jax.numpy as jnp
import matplotlib.pyplot as plt


def analytical_vibration(E, rho, v0, x_loc, duration, dt, L):
    t = jnp.arange(0, duration, dt)
    omega = 1 / L * jnp.sqrt(E / rho)
    v = v0 * jnp.cos(omega * t)
    x = x_loc * jnp.exp(v0 / (L * omega) * jnp.sin(omega * t))
    return x, v, t


E = 4 * jnp.pi**2
x, v, t = analytical_vibration(E, 1, 0.1, 1, 10, 0.01, 1)

fig, ax = plt.subplots()
ax.plot(t, v, "r", linewidth=1, label="analytical")
ax.grid()
ax.legend()
ax.set_xlabel("Time (s)")
ax.set_ylabel("Velocity (m/s)")
#+end_src

#+RESULTS:
:RESULTS:
: No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)
: Text(0, 0.5, 'Velocity (m/s)')
[[file:./.ob-jupyter/2b08e14f7c911d2b457691b5bd473e2b2d861844.png]]
:END:

Now, we can compare this with the output from ~diffmpm~.

#+begin_src jupyter-python
from diffmpm.mesh import Mesh1D
from diffmpm.material import Material

material = Material(E, 1)
mesh = Mesh1D(1, material, 1, jnp.array([0]), ppe=1)
velocity = jnp.array([0.1])
mesh.set_particle_velocity(velocity)
dt = 0.01
nsteps = int(10 / dt)
result = mesh.solve(dt=dt, nsteps=nsteps, mpm_scheme="USF")
#+end_src

#+RESULTS:
: 100% 1000/1000 [04:15<00:00,  3.91it/s]
:

#+begin_src jupyter-python
fig, ax = plt.subplots()
ax.plot(t, v, "r", linewidth=1, label="analytical")
ax.plot(t, result["velocity"], "k+", markersize=3, label="diffmpm")
ax.grid()
ax.legend()
ax.set_xlabel("Time (s)")
ax.set_ylabel("Velocity (m/s)")
#+end_src

#+RESULTS:
:RESULTS:
: Text(0, 0.5, 'Velocity (m/s)')
[[file:./.ob-jupyter/ed14a76f8c816049a3168d18338969ff126b84d7.png]]
:END:
* JIT Compatible classes
We see above that the simulated values are very close to the analytical values but the simulations are extremely slow. The main reason for this is that the funtions are not compiled just in time, which is one of the USPs of JAX.
All the classes that we developed above, while mostly differentiable, are not easily jit-compatible. The main reason for that is that since most of the methods are class methods, the first argument is ~self~ which is not hashable and doesn't work with JAX by default.
There are several ways to resolve this as per the [[https://jax.readthedocs.io/en/latest/faq.html#how-to-use-jit-with-methods][docs]] but the most complete way is to extend Pytree to include our custom classes ([[https://jax.readthedocs.io/en/latest/pytrees.html#what-is-a-pytree][Extending PyTrees]])
** Understanding Pytree structure of MPM Classes
By default, any container-like class is treated as a leaf node in pytree. This can be checked using the ~jax.tree_util.tree_structure~, ~jax.tree_util.tree_flatten~, and ~jax.tree_util.tree_unflatten~ function.

#+begin_src jupyter-python
from diffmpm.material import Material
from jax.tree_util import tree_structure, tree_flatten, tree_unflatten
def show_example(structured):
  flat, tree = tree_flatten(structured)
  unflattened = tree_unflatten(tree, flat)
  print(f"{structured=}\n  {flat=}\n  {tree=}\n  {unflattened=}")

show_example(Material(2, 1))
#+end_src

#+RESULTS:
: structured=Material(E=2, density=1)
:   flat=[Material(E=2, density=1)]
:   tree=PyTreeDef(*)
:   unflattened=Material(E=2, density=1)


We can extend/implement flatten/unflatten functions for the classes and register them as Pytree nodes to avoid this.

#+begin_src jupyter-python
class RegisteredMaterial(Material):
    def _tree_flatten(self):
        children = tuple()
        aux_data = {"E": self.E, "density": self.density}
        return (children, aux_data)

    @classmethod
    def _tree_unflatten(cls, aux_data, children):
        return cls(*children, **aux_data)


from jax import tree_util

tree_util.register_pytree_node(
    RegisteredMaterial,
    RegisteredMaterial._tree_flatten,
    RegisteredMaterial._tree_unflatten,
)
#+end_src

#+RESULTS:

#+begin_src jupyter-python
print(show_example(RegisteredMaterial(2, 1)))
#+end_src

#+RESULTS:
: structured=Material(E=2, density=1)
:   flat=[]
:   tree=PyTreeDef(CustomNode(RegisteredMaterial[{'E': 2, 'density': 1}], []))
:   unflattened=Material(E=2, density=1)
: None

We can also define the appropriate ~tree_flatten~ and ~tree_unflatten~ methods on the classes directly and decorate them with ~register_pytree_node_class()~.

#+begin_src jupyter-python
from diffmpm.material import Material
from diffmpm.particle import Particles

show_example(Particles(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1))
#+end_src

#+RESULTS:
: No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)
: structured=Particles(nparticles=1)
:   flat=[Array([1.], dtype=float32), 1, 1, Array([1.], dtype=float32), 1, 1, 1, 1, 1, 1, 1]
:   tree=PyTreeDef(CustomNode(Particles[{'material': None}], [*, *, *, *, *, *, *, *, *, *, *]))
:   unflattened=Particles(nparticles=1)
